<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2026-01-15T20:21:50+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">NicoDora</title><subtitle>백엔드 개발을 중심으로 포스트 하고 있는 NicoDora의 블로그입니다.</subtitle><author><name>NicoDora</name></author><entry><title type="html">[Nest.js] Google OAuth2.0 (OIDC) 로그인 구현하기</title><link href="http://localhost:4000/nestjs/Nest.js-Google-OAuth20-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[Nest.js] Google OAuth2.0 (OIDC) 로그인 구현하기" /><published>2026-01-15T20:03:00+09:00</published><updated>2026-01-15T20:03:00+09:00</updated><id>http://localhost:4000/nestjs/%5BNest.js%5D-Google-OAuth20-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/nestjs/Nest.js-Google-OAuth20-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/"><![CDATA[<ol id="markdown-toc">
  <li><a href="#oauth20과-oidc의-차이점" id="markdown-toc-oauth20과-oidc의-차이점">OAuth2.0과 OIDC의 차이점</a></li>
  <li><a href="#oidc-인증-흐름-이해하기" id="markdown-toc-oidc-인증-흐름-이해하기">OIDC 인증 흐름 이해하기</a></li>
  <li><a href="#google-cloud-console에서-oauth-20-클라이언트-설정하기" id="markdown-toc-google-cloud-console에서-oauth-20-클라이언트-설정하기">Google Cloud Console에서 OAuth 2.0 클라이언트 설정하기</a></li>
  <li><a href="#백엔드-코드-작성하기" id="markdown-toc-백엔드-코드-작성하기">백엔드 코드 작성하기</a>    <ol>
      <li><a href="#get-authgoogle-api-구현하기" id="markdown-toc-get-authgoogle-api-구현하기">GET /auth/google API 구현하기</a></li>
      <li><a href="#state와-nonce의-역할" id="markdown-toc-state와-nonce의-역할">State와 Nonce의 역할</a></li>
      <li><a href="#post-authgoogleauthenticate-api-구현하기" id="markdown-toc-post-authgoogleauthenticate-api-구현하기">POST /auth/google/authenticate API 구현하기</a></li>
    </ol>
  </li>
  <li><a href="#프론트엔드에서-필요한-작업" id="markdown-toc-프론트엔드에서-필요한-작업">프론트엔드에서 필요한 작업</a></li>
  <li><a href="#구글-로그인-테스트하기" id="markdown-toc-구글-로그인-테스트하기">구글 로그인 테스트하기</a></li>
  <li><a href="#마치며" id="markdown-toc-마치며">마치며</a>    <ol>
      <li><a href="#state-값-저장방식-쿠키-vs-서버" id="markdown-toc-state-값-저장방식-쿠키-vs-서버">state 값 저장방식 (쿠키 vs 서버)</a></li>
      <li><a href="#인가-코드-콜백은-어디로-클라이언트-vs-서버" id="markdown-toc-인가-코드-콜백은-어디로-클라이언트-vs-서버">인가 코드 콜백은 어디로? (클라이언트 vs 서버)</a></li>
    </ol>
  </li>
  <li><a href="#참고-자료" id="markdown-toc-참고-자료">참고 자료</a></li>
</ol>

<h2 id="oauth20과-oidc의-차이점">OAuth2.0과 OIDC의 차이점</h2>

<p>OAuth2.0을 사용하여 구글 로그인을 구현하기 전에, 많은 분들이 혼동하는 OAuth2.0과 OIDC(OpenID Connect)의 차이점에 대해 간단히 짚고 넘어가려 합니다.
<br />
<br />
<strong>OAuth2.0</strong>은 권한 부여 프레임워크로, 사용자가 애플리케이션에 특정 리소스에 대한 접근 권한을 부여할 수 있도록 합니다. 반면, <strong>OIDC(OpenID Connect)</strong>는 OAuth2.0 위에 구축된 인증 프로토콜로, 사용자의 신원을 확인하고 인증 정보를 제공하는 데 중점을 둡니다.
<br />
<br /></p>
<ul>
  <li><b>OAuth2.0 - 권한 부여(Authorization)</b>
    <ul>
      <li>사용자가 애플리케이션에 특정 리소스에 대한 접근 권한을 부여.</li>
      <li>예) 사용자가 애플리케이션에 자신의 구글 드라이브 파일에 접근할 수 있는 권한을 부여.</li>
    </ul>
  </li>
  <li><b>OIDC (OpenID Connect) - 인증(Authentication)</b>
    <ul>
      <li>사용자의 신원을 확인하고 인증 정보를 제공.</li>
      <li>예) 사용자가 애플리케이션에 구글 계정으로 로그인.</li>
    </ul>
  </li>
</ul>

<p><br />
몇몇 개발자분들의 글을 보면 ‘OAuth2.0을 사용하여 소셜 로그인을 구현했다’ 라고 하는데 물론 OAuth2.0을 사용하여 로그인을 구현할 수 있지만, OAuth2.0을 사용하여 로그인을 구현하면 아래와 같은 문제가 발생할 수 있습니다.
<br />
<br />
<b>OAuth 인증 시 주요 문제점</b></p>
<ol>
  <li><b>액세스 토큰을 인증 증거로 오해</b>
    <ul>
      <li>액세스 토큰은 보호된 리소스에 접근하기 위한 권한 부여 수단일 뿐, 그 자체로 사용자 인증을 증명하지는 않습니다.<br />
클라이언트는 토큰의 내용을 알 수 없으므로 사용자 정보를 직접 유도하기 어렵습니다.<br />
(쉬운 예시로, 놀이공원에 입장하는 티켓(액세스 토큰)을 통해 놀이공원(리소스 서버)에 들어갈 수는 있지만, 티켓만으로 그 사람이 누구인지(인증)를 알 수 없는 것과 같습니다.)</li>
    </ul>
  </li>
  <li><b>API 접근 성공을 인증으로 간주</b>
    <ul>
      <li>유효한 토큰으로 사용자 정보를 가져올 수 있다고 해서 사용자가 현재 로그인 상태라고 단정할 수 없습니다.<br />
리프레시 토큰이나 권한 위임을 통해 사용자 없이도 토큰 발급이 가능하며, 사용자가 떠난 후에도 토큰은 한동안 유효하기 때문입니다.</li>
    </ul>
  </li>
</ol>

<blockquote>
  <p><a href="https://oauth.net/articles/authentication/#:~:text=Common%20pitfalls%20for%20authentication%20using%20OAuth">OAuth 공식 문서</a>에서 인증에 OAuth를 사용하는 것을 권장하지 않는 이유에 대해 자세히 살펴볼 수 있습니다.</p>
</blockquote>

<p><br />
OAuth2.0과 OIDC 각각 사용자 정보를 얻는 흐름을 간단히 비교해보면 다음과 같습니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/oauth-vs-oidc.png" alt="OAuth2.0 vs OIDC" />
<br />
<br />
OIDC의 경우, OAuth2.0의 흐름에 ID 토큰이 추가되어 사용자의 신원을 확인할 수 있도록 합니다. ID 토큰은 JWT(JSON Web Token) 형식으로 발급되며, 사용자의 정보(예: 이메일, 이름 등)를 포함하고 있습니다.
<br />
<br />
ID 토큰을 통해 사용자 정보를 얻을 수 있기 때문에 사용자 정보를 가져오기 위한 별도의 API 호출이 필요하지 않아 네트워크 비용을 줄일 수 있고 더 안전하게 인증을 처리할 수 있습니다.
<br />
<br />
따라서 이번 포스팅에서는 OIDC를 사용하여 구글 로그인을 구현하는 방법에 대해 알아보겠습니다.</p>

<h2 id="oidc-인증-흐름-이해하기">OIDC 인증 흐름 이해하기</h2>

<p>다음은 OIDC 인증 흐름을 나타낸 다이어그램입니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/oidc-flow.png" alt="OIDC 인증 흐름" width="400" />
<br />
<br /></p>
<details>
<summary><b>OIDC 인증 흐름 설명 보기</b></summary>
<div>
    <ol>
      <li><b>로그인 요청</b>
        <ul>
          <li>사용자가 ‘구글 로그인’ 버튼을 클릭합니다.</li>
          <li>클라이언트는 서버에 로그인을 요청하고, 서버는 사용자를 구글의 인증 페이지로 리다이렉트(Redirect)시킵니다.\
이때 scope 파라미터에 반드시 <strong><code class="language-plaintext highlighter-rouge">openid</code></strong>를 포함해야 하며, 추가로 <code class="language-plaintext highlighter-rouge">email</code>, <code class="language-plaintext highlighter-rouge">profile</code> 등을 요청합니다.</li>
        </ul>
      </li>
      <li><b>인증 및 권한 승인</b>
        <ul>
          <li>사용자가 구글 로그인 페이지에서 아이디/비밀번호를 입력하고, 서비스가 요청한 정보 제공에 동의합니다.</li>
          <li>구글 인증 서버는 사용자의 신원을 확인하고, 해당 서비스가 사용자의 정보를 가져가는 것에 동의했는지 체크합니다.</li>
        </ul>
      </li>
      <li><b>인가 코드 발급</b>
        <ul>
          <li>구글 인증 서버가 브라우저를 통해 클라이언트의 콜백(Callback) URL로 <strong>인가 코드</strong>를 전달합니다.</li>
          <li>이 코드는 일종의 ‘교환권’으로, 보안을 위해 짧은 시간 동안만 유효합니다.</li>
        </ul>
      </li>
      <li><b>토큰 교환 요청</b>
        <ul>
          <li>클라이언트가 ‘인가 코드’를 들고 토큰을 발급받는 서버(Backend) API에 요청을 보냅니다. 그리고 서버에선 인가 코드를 들고 구글 인증 서버에 실제 토큰을 요청합니다.</li>
          <li>이때 서버는 자신의 <code class="language-plaintext highlighter-rouge">Client ID</code>와 <code class="language-plaintext highlighter-rouge">Client Secret</code>을 함께 보내어 정당한 서버임을 증명합니다.</li>
        </ul>
      </li>
      <li><b>ID 토큰 및 액세스 토큰 발급</b>
        <ul>
          <li>구글 인증 서버는 코드를 검증한 후, <strong>ID 토큰</strong>과 <strong>액세스 토큰</strong>을 서버에 발급합니다.</li>
          <li>(OIDC에서는 유저 정보가 담긴 JWT 형태의 ID 토큰이 함께 돌아옵니다.)</li>
        </ul>
      </li>
      <li><b>ID 토큰 검증 및 유저 정보 획득</b>
        <ul>
          <li>서버는 받은 ID 토큰을 디코딩하여 유저의 이메일, 이름, 고유 식별자(sub) 등을 추출합니다.</li>
          <li>별도의 API 호출(구글 리소스 서버 요청) 없이도 토큰 자체를 검증(Signature 확인)함으로써 유저 정보를 즉시 확인할 수 있습니다. 이 과정에서 네트워크 비용이 절감됩니다.</li>
        </ul>
      </li>
      <li><b>서비스 로그인 완료</b>
        <ul>
          <li>획득한 유저 정보를 DB에 저장하거나 확인한 후, 우리 서비스 전용 토큰(JWT 등)을 발급하여 사용자에게 응답합니다.</li>
          <li>사용자는 최종적으로 서비스에 로그인된 상태가 됩니다.</li>
        </ul>
      </li>
    </ol>
  </div>
</details>
<p><br />
<br />
처음 설명을 보면 이해하기 어려울 수 있기에 <a href="https://developers.google.com/oauthplayground/">Google OAuth Playground</a>에서 직접 OAuth 관련 요청을 시도해보는걸 추천드립니다.
<br />
<br />
사이트에 들어가보면 다음과 같은 화면이 나옵니다.<br />
좌측 패널을 보시면 총 3단계로 나누어져 있습니다.
<br />
<br />
Step 1에서는 다양한 구글 API에 대한 인증 요청을 선택하여 시도해볼 수 있습니다.<br />
Step 2에서는 인가 코드를 교환하여 액세스 토큰을 발급받는 과정을 시도해볼 수 있습니다.<br />
Step 3에서는 발급받은 액세스 토큰을 사용하여 구글 API를 호출해볼 수 있습니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/oauth-playground.png" alt="OAuth Playground" />
<br />
<br /></p>

<p>오른쪽 톱니바퀴를 누르면 설정 창이 나오게 되는데 일단 기본 설정으로 두고 시작하겠습니다. (나중에 커스텀 설정을 통해 내 서비스의 구글 로그인을 테스트 해볼 수 있습니다.)
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/oauth-playground-setting.png" alt="OAuth Playground Setting" />
<br />
<br /></p>

<p>Step 1에서 <b>Google OAuth2 API v2</b>를 선택하고 <code class="language-plaintext highlighter-rouge">https://www.googleapis.com/auth/userinfo.email</code>, <code class="language-plaintext highlighter-rouge">https://www.googleapis.com/auth/userinfo.profile</code>, <code class="language-plaintext highlighter-rouge">openid</code> 스코프를 추가합니다.<br />
그리고 <b>Authorize APIs</b> 버튼을 클릭합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/oauth-playground-scope.png" alt="OAuth Playground Scope" width="400" />
<br />
<br /></p>

<p>그러면 구글 로그인 페이지로 리다이렉트되며, 로그인을 진행하고 권한을 승인합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/oauth-playground-login.png" alt="OAuth Playground Login" />
<br />
<br /></p>

<p>승인 후에는 다시 OAuth Playground로 리다이렉트 되고 인가 코드를 발급받게됩니다.
<br />
<br />
여기까지가 ‘로그인 버튼 클릭’ 부터 ‘인가 코드 발급’까지의 흐름입니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/oauth-playground-authorized.png" alt="OAuth Playground Authorized" width="400" />
<br />
<br /></p>

<p>이제 Step 2에서 인가 코드를 교환하여 액세스 토큰을 발급받을 수 있습니다.<br />
<b>Exchange authorization code for tokens</b> 버튼을 클릭합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/oauth-playground-exchange.png" alt="OAuth Playground Exchange" />
<br />
<br /></p>

<p>그러면 액세스 토큰, 리프레시 토큰과 함께 <b>ID 토큰</b>도 발급받는 것을 확인할 수 있습니다.<br />
액세스 토큰을 사용하여 Step 3에서 다른 구글 API를 호출해볼 수 있습니다만 지금은 구글 로그인 구현이 목적이기에 Step 3까지 진행하지 않아도 됩니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/oauth-playground-tokens.png" alt="OAuth Playground Tokens" />
<br />
<br /></p>

<p>ID 토큰은 JWT 형식으로 되어 있으며, <a href="https://jwt.io/">jwt.io</a>에서 디코딩해보면 다음과 같이 사용자 정보가 포함되어 있는 것을 확인할 수 있습니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/oauth-playground-id-token.png" alt="OAuth Playground ID Token" />
<br /></p>

<blockquote>
  <p>구글 ID 토큰의 페이로드에 대한 정보는 <a href="https://developers.google.com/identity/openid-connect/openid-connect?hl=ko#an-id-tokens-payload">ID 토큰의 페이로드</a> 문서를 참고해주세요.</p>
</blockquote>

<p><br />
ID 토큰 디코딩은 실제 서버에서 수행하며, 여기까지가 ‘인가 코드를 가지고 서비스 토큰 발급 요청’부터 ‘ID 토큰을 디코딩하여 사용자 정보 획득’까지의 흐름입니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/oauth-playground-id-token-decoded.png" alt="OAuth Playground ID Token Decoded" width="400" /></p>

<h2 id="google-cloud-console에서-oauth-20-클라이언트-설정하기">Google Cloud Console에서 OAuth 2.0 클라이언트 설정하기</h2>

<p>구글 로그인을 구현하기 위해서는 먼저 <a href="https://console.cloud.google.com/">Google Cloud Console</a>에서 OAuth 2.0 클라이언트를 설정해야 합니다.<br />
Google Cloud Console에 접속한 후, 새 프로젝트를 생성하고 ‘API 및 서비스’ &gt; ‘OAuth 동의 화면’ 메뉴를 클릭합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/google-cloud-oauth-consent-screen.png" alt="Google Cloud Console OAuth Consent Screen" />
<br />
<br /></p>

<p>OAuth 개요에서 ‘시작하기’ 버튼을 클릭하여 프로젝트 구성을 시작합니다.<br />
앱 이름, 사용자 지원 이메일, 개발자 연락처 정보 등을 알맞게 입력하시고 대상 유형은 ‘외부’를 선택합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/google-cloud-oauth-consent-start.png" alt="Google Cloud Console OAuth Consent Start" />
<br />
<br /></p>

<p>프로젝트 구성을 완료한 후, ‘OAuth 클라이언트 만들기’를 클릭하여 OAuth 2.0 클라이언트를 생성합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/google-cloud-create-oauth-client.png" alt="Google Cloud Console Create OAuth Client" />
<br />
<br /></p>

<p>애플리케이션 유형은 ‘웹 애플리케이션’을 선택하고, 이름을 입력합니다.<br />
‘승인된 JavaScript 원본’에는 클라이언트의 도메인을 입력하고, ‘승인된 리디렉션 URI’에는 구글 인증 후 리다이렉트될 클라이언트의 콜백 URL을 입력합니다.<br />
(일단 로컬에서 테스트할 예정이기에 localhost를 사용하였지만, 실제 서비스에서는 배포된 도메인을 사용해야 합니다.)
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/google-cloud-oauth-client-settings.png" alt="Google Cloud Console Create OAuth Client Settings" width="600" />
<br />
<br /></p>

<p>설정을 완료하고 ‘만들기’ 버튼을 클릭하면 클라이언트 ID와 클라이언트 보안 비밀번호가 발급됩니다.<br />
클라이언트 보안 비밀번호는 모달 창을 닫으면 다시 볼 수 없으니 안전한 곳에 보관해주세요!
<br />
<br />
다음으로 ‘데이터 액세스’ 탭으로 이동해서 ‘범위 추가 또는 삭제’ 버튼을 클릭합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/google-cloud-oauth-scopes.png" alt="Google Cloud Console OAuth Scopes" />
<br />
<br /></p>

<p><code class="language-plaintext highlighter-rouge">.../auth/userinfo.email</code>, <code class="language-plaintext highlighter-rouge">.../auth/userinfo.profile</code>, <code class="language-plaintext highlighter-rouge">openid</code> 범위를 선택하고 ‘업데이트’ 버튼을 클릭합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/google-cloud-oauth-add-scopes.png" alt="Google Cloud Console OAuth Add Scopes" />
<br />
<br /></p>

<p>‘민감하지 않는 범위’에 선택한 범위들이 추가되었다면 아래 ‘Save’ 버튼을 클릭하여 저장합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/google-cloud-oauth-scopes-saved.png" alt="Google Cloud Console OAuth Scopes Saved" />
<br />
<br /></p>

<p>이제 ‘대상’ 탭으로 이동하여 ‘Add users’ 버튼을 클릭하고 테스트 사용자로 사용할 구글 계정을 추가합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/google-cloud-oauth-add-test-users.png" alt="Google Cloud Console OAuth Add Test Users" />
<br />
<br />
이렇게 구글 OAuth 2.0 클라이언트 설정이 완료되었습니다.<br />
이제 Nest.js 환경에서 구글 로그인을 구현해보겠습니다.</p>

<h2 id="백엔드-코드-작성하기">백엔드 코드 작성하기</h2>

<p>코드를 작성하기 전에 OIDC 인증을 위해 백엔드에서 구현해야 하는 기능들을 간단히 정리해보면 아래와 같습니다.</p>

<ol>
  <li><b>클라이언트에서 구글 로그인 요청을 처리하는 API 구현</b> (<code class="language-plaintext highlighter-rouge">GET /auth/google</code>)</li>
  <li><b>클라이언트로부터 인가 코드를 받아 서비스 토큰을 발급하는 API 구현</b> (<code class="language-plaintext highlighter-rouge">POST /auth/google/authenticate</code>)
    <ul>
      <li>인가 코드를 구글 인증 서버에 전달하여 ID 토큰과 액세스 토큰 발급 요청</li>
      <li>구글로부터 받은 ID 토큰을 검증하고 사용자 정보 추출</li>
      <li>추출한 사용자 정보를 바탕으로 서비스 로그인 처리</li>
    </ul>
  </li>
</ol>

<h3 id="get-authgoogle-api-구현하기">GET /auth/google API 구현하기</h3>

<p>아래는 첫번째 기능인 <b>‘클라이언트에서 구글 로그인 요청을 처리하는 API’</b>를 구현한 코드입니다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// File: "auth.controller.ts"</span>
<span class="c1">// ... import statements ...</span>

<span class="p">@</span><span class="nd">ApiTags</span><span class="p">(</span><span class="dl">"</span><span class="s2">Auth (인증)</span><span class="dl">"</span><span class="p">)</span>
<span class="p">@</span><span class="nd">Controller</span><span class="p">(</span><span class="dl">"</span><span class="s2">auth</span><span class="dl">"</span><span class="p">)</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nc">AuthController</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">authService</span><span class="p">:</span> <span class="nx">AuthService</span><span class="p">,</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">googleAuthService</span><span class="p">:</span> <span class="nx">GoogleAuthService</span><span class="p">,</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">appConfigService</span><span class="p">:</span> <span class="nx">AppConfigService</span><span class="p">,</span>
  <span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// ... other endpoints ...</span>

  <span class="p">@</span><span class="nd">ApiAuth</span><span class="p">.</span><span class="nf">googleLogin</span><span class="p">()</span>
  <span class="p">@</span><span class="nd">Get</span><span class="p">(</span><span class="dl">"</span><span class="s2">google</span><span class="dl">"</span><span class="p">)</span>
  <span class="p">@</span><span class="nd">HttpCode</span><span class="p">(</span><span class="nx">HttpStatus</span><span class="p">.</span><span class="nx">FOUND</span><span class="p">)</span>
  <span class="nf">googleLogin</span><span class="p">(@</span><span class="nd">Res</span><span class="p">()</span> <span class="nx">res</span><span class="p">:</span> <span class="nx">Response</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">nonce</span> <span class="p">}:</span> <span class="nx">IGoogleAuthOptions</span> <span class="o">=</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">googleAuthService</span><span class="p">.</span><span class="nf">generateAuthOptions</span><span class="p">();</span>

    <span class="kd">const</span> <span class="nx">cookieOptions</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nf">getCommonCookieOptions</span><span class="p">(</span>
      <span class="nx">COOKIE_MAX_AGE</span><span class="p">.</span><span class="nx">GOOGLE_OAUTH</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="c1">// 쿠키에 state와 nonce 저장</span>
    <span class="nx">res</span><span class="p">.</span><span class="nf">cookie</span><span class="p">(</span><span class="nx">COOKIE_NAME</span><span class="p">.</span><span class="nx">GOOGLE_STATE</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">cookieOptions</span><span class="p">);</span>
    <span class="nx">res</span><span class="p">.</span><span class="nf">cookie</span><span class="p">(</span><span class="nx">COOKIE_NAME</span><span class="p">.</span><span class="nx">GOOGLE_NONCE</span><span class="p">,</span> <span class="nx">nonce</span><span class="p">,</span> <span class="nx">cookieOptions</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nf">redirect</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ... other endpoints ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>코드를 살펴보면, <code class="language-plaintext highlighter-rouge">GET /auth/google</code> 엔드포인트에서 <code class="language-plaintext highlighter-rouge">GoogleAuthService</code>의 <code class="language-plaintext highlighter-rouge">generateAuthOptions()</code> 메서드를 호출하여 구글 인증 URL과 함께 보안 파라미터인 <code class="language-plaintext highlighter-rouge">state</code>, <code class="language-plaintext highlighter-rouge">nonce</code>를 가져오고 있습니다.<br />
그 후에 <code class="language-plaintext highlighter-rouge">state</code>와 <code class="language-plaintext highlighter-rouge">nonce</code>를 쿠키에 저장한 뒤, 클라이언트를 구글 인증 페이지로 리다이렉트시키고 있습니다.
<br />
<br />
다음으로 <code class="language-plaintext highlighter-rouge">GoogleAuthService</code>의 <code class="language-plaintext highlighter-rouge">generateAuthOptions()</code> 메서드 코드를 살펴보겠습니다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// File: "google-auth.service.ts"</span>
<span class="c1">// ... import statements ...</span>

<span class="p">@</span><span class="nd">Injectable</span><span class="p">()</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nc">GoogleAuthService</span> <span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="nx">googleClient</span><span class="p">:</span> <span class="nx">OAuth2Client</span><span class="p">;</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="nx">logger</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Logger</span><span class="p">(</span><span class="nx">GoogleAuthService</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>

  <span class="nf">constructor</span><span class="p">(</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">appConfigService</span><span class="p">:</span> <span class="nx">AppConfigService</span><span class="p">,</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">userService</span><span class="p">:</span> <span class="nx">UserService</span><span class="p">,</span>
    <span class="p">@</span><span class="nd">Inject</span><span class="p">(</span><span class="nx">AUTH_TOKENS</span><span class="p">.</span><span class="nx">ITokenService</span><span class="p">)</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">tokenService</span><span class="p">:</span> <span class="nx">ITokenService</span><span class="p">,</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">googleClient</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OAuth2Client</span><span class="p">({</span>
      <span class="na">clientId</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">appConfigService</span><span class="p">.</span><span class="nx">googleClientId</span><span class="p">,</span>
      <span class="na">clientSecret</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">appConfigService</span><span class="p">.</span><span class="nx">googleClientSecret</span><span class="p">,</span>
      <span class="na">redirectUri</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">appConfigService</span><span class="p">.</span><span class="nx">googleRedirectUri</span><span class="p">,</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="cm">/**
   * 구글 인증 URL 생성 및 보안 파라미터(state, nonce) 발급
   */</span>
  <span class="nf">generateAuthOptions</span><span class="p">():</span> <span class="nx">IGoogleAuthOptions</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">구글 인증 URL 생성을 시작합니다.</span><span class="dl">"</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">rootUrl</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">https://accounts.google.com/o/oauth2/v2/auth</span><span class="dl">"</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">state</span> <span class="o">=</span> <span class="nf">nanoid</span><span class="p">(</span><span class="nx">STATE_LENGTH</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">nonce</span> <span class="o">=</span> <span class="nf">nanoid</span><span class="p">(</span><span class="nx">NONCE_LENGTH</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">client_id</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">appConfigService</span><span class="p">.</span><span class="nx">googleClientId</span><span class="p">,</span>
      <span class="na">redirect_uri</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">appConfigService</span><span class="p">.</span><span class="nx">googleRedirectUri</span><span class="p">,</span>
      <span class="na">response_type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">code</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">scope</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">openid</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">email</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">profile</span><span class="dl">"</span><span class="p">].</span><span class="nf">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">),</span>
      <span class="na">access_type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">offline</span><span class="dl">"</span><span class="p">,</span>
      <span class="nx">state</span><span class="p">,</span>
      <span class="nx">nonce</span><span class="p">,</span>
      <span class="na">prompt</span><span class="p">:</span> <span class="dl">"</span><span class="s2">select_account</span><span class="dl">"</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">return</span> <span class="p">{</span>
      <span class="na">url</span><span class="p">:</span> <span class="s2">`</span><span class="p">${</span><span class="nx">rootUrl</span><span class="p">}</span><span class="s2">?</span><span class="p">${</span><span class="k">new</span> <span class="nc">URLSearchParams</span><span class="p">(</span><span class="nx">options</span><span class="p">).</span><span class="nf">toString</span><span class="p">()}</span><span class="s2">`</span><span class="p">,</span>
      <span class="nx">state</span><span class="p">,</span>
      <span class="nx">nonce</span><span class="p">,</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="c1">// ... other methods ...</span>
<span class="p">}</span>
</code></pre></div></div>
<blockquote>
  <p>인증 URL Parameter에 대한 자세한 내용은 <a href="https://developers.google.com/identity/openid-connect/openid-connect?hl=ko#authenticationuriparameters">여기</a>를 참고해주세요.</p>
</blockquote>

<p><br />
<code class="language-plaintext highlighter-rouge">nanoid</code> 라이브러리를 사용하여 <code class="language-plaintext highlighter-rouge">state</code>와 <code class="language-plaintext highlighter-rouge">nonce</code>를 생성하고 있는데 각각 어떤 역할을 하는지 간단히 설명드리겠습니다.</p>

<h3 id="state와-nonce의-역할">State와 Nonce의 역할</h3>

<ul>
  <li><b>State</b>
    <ul>
      <li>CSRF(Cross-Site Request Forgery) 공격을 방지하기 위한 보안 토큰입니다.</li>
      <li>클라이언트가 구글 로그인 요청을 서버로 보낼 때 생성하여 클라이언트에 전송하고, 구글 인증 서버는 이 값을 포함시켜 응답합니다.</li>
      <li>클라이언트가 이후에 서버에 서비스 토큰을 요청할 때, 서버는 <code class="language-plaintext highlighter-rouge">state</code> 값이 이전에 클라이언트에게 응답으로 보낸 값과 일치하는지 확인하여 요청의 정당성을 검증합니다.</li>
    </ul>
  </li>
  <li><b>Nonce</b>
    <ul>
      <li>재전송 공격(Replay Attack)을 방지하기 위한 임의의 값입니다.</li>
      <li>클라이언트가 구글 로그인 요청을 서버로 보낼 때 생성하여 클라이언트에 전송하고, 구글 인증 서버는 ID 토큰에 이 값을 포함시켜 응답합니다.</li>
      <li>서버는 ID 토큰에서 받은 <code class="language-plaintext highlighter-rouge">nonce</code> 값이 이전에 클라이언트에게 응답으로 보낸 값과 일치하는지 확인하여 토큰의 유효성을 검증합니다.</li>
    </ul>
  </li>
</ul>

<p>즉, <code class="language-plaintext highlighter-rouge">state</code>는 클라이언트의 요청이 위변조되지 않았는지 검증하는 역할을 하고, <code class="language-plaintext highlighter-rouge">nonce</code>는 ID 토큰이 변조되지 않았는지 검증하는 역할을 합니다.
<br />
<br />
위 코드를 정리해보면 <code class="language-plaintext highlighter-rouge">GET /auth/google</code> 엔드포인트에서 구글 인증 URL과 함께 <code class="language-plaintext highlighter-rouge">state</code>, <code class="language-plaintext highlighter-rouge">nonce</code>를 생성하여 클라이언트를 구글 인증 페이지로 리다이렉트시키는 기능을 구현한 것입니다.</p>

<h3 id="post-authgoogleauthenticate-api-구현하기">POST /auth/google/authenticate API 구현하기</h3>

<p>다음은 두번째 기능인 <b>‘클라이언트로부터 인가 코드를 받아 서비스 토큰을 발급하는 API’</b>를 구현한 코드입니다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// File: "auth.controller.ts"</span>
<span class="c1">// ... import statements ...</span>

<span class="p">@</span><span class="nd">ApiTags</span><span class="p">(</span><span class="dl">"</span><span class="s2">Auth (인증)</span><span class="dl">"</span><span class="p">)</span>
<span class="p">@</span><span class="nd">Controller</span><span class="p">(</span><span class="dl">"</span><span class="s2">auth</span><span class="dl">"</span><span class="p">)</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nc">AuthController</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">authService</span><span class="p">:</span> <span class="nx">AuthService</span><span class="p">,</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">googleAuthService</span><span class="p">:</span> <span class="nx">GoogleAuthService</span><span class="p">,</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">appConfigService</span><span class="p">:</span> <span class="nx">AppConfigService</span><span class="p">,</span>
  <span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// ... other endpoints ...</span>

  <span class="p">@</span><span class="nd">ApiAuth</span><span class="p">.</span><span class="nf">googleAuthenticate</span><span class="p">()</span>
  <span class="p">@</span><span class="nd">Post</span><span class="p">(</span><span class="dl">"</span><span class="s2">google/authenticate</span><span class="dl">"</span><span class="p">)</span>
  <span class="p">@</span><span class="nd">HttpCode</span><span class="p">(</span><span class="nx">HttpStatus</span><span class="p">.</span><span class="nx">OK</span><span class="p">)</span>
  <span class="p">@</span><span class="nd">ResponseMessage</span><span class="p">(</span><span class="dl">"</span><span class="s2">구글 로그인에 성공하였습니다.</span><span class="dl">"</span><span class="p">)</span>
  <span class="k">async</span> <span class="nf">googleAuthenticate</span><span class="p">(</span>
    <span class="p">@</span><span class="nd">Body</span><span class="p">(</span><span class="dl">"</span><span class="s2">code</span><span class="dl">"</span><span class="p">)</span> <span class="nx">code</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
    <span class="p">@</span><span class="nd">Body</span><span class="p">(</span><span class="dl">"</span><span class="s2">state</span><span class="dl">"</span><span class="p">)</span> <span class="nx">requestState</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
    <span class="p">@</span><span class="nd">Req</span><span class="p">()</span> <span class="nx">req</span><span class="p">:</span> <span class="nx">Request</span><span class="p">,</span>
    <span class="p">@</span><span class="nd">Res</span><span class="p">({</span> <span class="na">passthrough</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span> <span class="nx">res</span><span class="p">:</span> <span class="nx">Response</span><span class="p">,</span>
  <span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">AccessTokenResponseDto</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">code</span> <span class="o">||</span> <span class="o">!</span><span class="nx">requestState</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">UnauthorizedException</span><span class="p">(</span>
        <span class="dl">"</span><span class="s2">필수 인증 파라미터(code, state)가 누락되었습니다.</span><span class="dl">"</span><span class="p">,</span>
      <span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">const</span> <span class="nx">savedState</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">cookies</span><span class="p">[</span><span class="nx">COOKIE_NAME</span><span class="p">.</span><span class="nx">GOOGLE_STATE</span><span class="p">];</span>
    <span class="kd">const</span> <span class="nx">savedNonce</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">cookies</span><span class="p">[</span><span class="nx">COOKIE_NAME</span><span class="p">.</span><span class="nx">GOOGLE_NONCE</span><span class="p">];</span>

    <span class="kd">const</span> <span class="na">params</span><span class="p">:</span> <span class="nx">IHandleGoogleLoginParams</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">code</span><span class="p">,</span>
      <span class="nx">savedState</span><span class="p">,</span>
      <span class="nx">requestState</span><span class="p">,</span>
      <span class="nx">savedNonce</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">accessToken</span><span class="p">,</span> <span class="nx">refreshToken</span> <span class="p">}</span> <span class="o">=</span>
      <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">googleAuthService</span><span class="p">.</span><span class="nf">handleGoogleLogin</span><span class="p">(</span><span class="nx">params</span><span class="p">);</span>

    <span class="nx">res</span><span class="p">.</span><span class="nf">clearCookie</span><span class="p">(</span><span class="nx">COOKIE_NAME</span><span class="p">.</span><span class="nx">GOOGLE_STATE</span><span class="p">);</span>
    <span class="nx">res</span><span class="p">.</span><span class="nf">clearCookie</span><span class="p">(</span><span class="nx">COOKIE_NAME</span><span class="p">.</span><span class="nx">GOOGLE_NONCE</span><span class="p">);</span>

    <span class="nx">res</span><span class="p">.</span><span class="nf">cookie</span><span class="p">(</span>
      <span class="nx">COOKIE_NAME</span><span class="p">.</span><span class="nx">REFRESH_TOKEN</span><span class="p">,</span>
      <span class="nx">refreshToken</span><span class="p">,</span>
      <span class="k">this</span><span class="p">.</span><span class="nf">getCommonCookieOptions</span><span class="p">(</span><span class="nx">COOKIE_MAX_AGE</span><span class="p">.</span><span class="nx">REFRESH_TOKEN</span><span class="p">),</span>
    <span class="p">);</span>

    <span class="k">return</span> <span class="p">{</span> <span class="nx">accessToken</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">POST /auth/google/authenticate</code>에선 클라이언트 Body로 인가 코드(<code class="language-plaintext highlighter-rouge">code</code>)와 <code class="language-plaintext highlighter-rouge">requestState</code>, 쿠키로 <code class="language-plaintext highlighter-rouge">savedState</code>와 <code class="language-plaintext highlighter-rouge">savedNonce</code> 값을 받아 <code class="language-plaintext highlighter-rouge">GoogleAuthService</code>의 <code class="language-plaintext highlighter-rouge">handleGoogleLogin()</code> 메서드를 호출하여 서비스 토큰을 생성하고 있습니다.
<br />
<br />
<code class="language-plaintext highlighter-rouge">GoogleAuthService</code>의 <code class="language-plaintext highlighter-rouge">handleGoogleLogin()</code> 메서드에선 어떻게 서비스 토큰을 만드는지 살펴보겠습니다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// File: "google-auth.service.ts"</span>
<span class="c1">// ... import statements ...</span>

<span class="p">@</span><span class="nd">Injectable</span><span class="p">()</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nc">GoogleAuthService</span> <span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="nx">googleClient</span><span class="p">:</span> <span class="nx">OAuth2Client</span><span class="p">;</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="nx">logger</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Logger</span><span class="p">(</span><span class="nx">GoogleAuthService</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>

  <span class="nf">constructor</span><span class="p">(</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">appConfigService</span><span class="p">:</span> <span class="nx">AppConfigService</span><span class="p">,</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">userService</span><span class="p">:</span> <span class="nx">UserService</span><span class="p">,</span>
    <span class="p">@</span><span class="nd">Inject</span><span class="p">(</span><span class="nx">AUTH_TOKENS</span><span class="p">.</span><span class="nx">ITokenService</span><span class="p">)</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">tokenService</span><span class="p">:</span> <span class="nx">ITokenService</span><span class="p">,</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">googleClient</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OAuth2Client</span><span class="p">({</span>
      <span class="na">clientId</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">appConfigService</span><span class="p">.</span><span class="nx">googleClientId</span><span class="p">,</span>
      <span class="na">clientSecret</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">appConfigService</span><span class="p">.</span><span class="nx">googleClientSecret</span><span class="p">,</span>
      <span class="na">redirectUri</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">appConfigService</span><span class="p">.</span><span class="nx">googleRedirectUri</span><span class="p">,</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="c1">// ... other methods ...</span>

  <span class="cm">/**
   * 콜백 처리: 구글 인가 코드를 우리 서비스의 토큰으로 교환
   */</span>
  <span class="k">async</span> <span class="nf">handleGoogleLogin</span><span class="p">(</span>
    <span class="nx">params</span><span class="p">:</span> <span class="nx">IHandleGoogleLoginParams</span><span class="p">,</span>
  <span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">LoginResponseDto</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">code</span><span class="p">,</span> <span class="nx">savedState</span><span class="p">,</span> <span class="nx">requestState</span><span class="p">,</span> <span class="nx">savedNonce</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">params</span><span class="p">;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">구글 로그인을 처리합니다.</span><span class="dl">"</span><span class="p">);</span>

    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">code</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">UnauthorizedException</span><span class="p">(</span><span class="dl">"</span><span class="s2">인증 코드가 없습니다.</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">savedState</span> <span class="o">||</span> <span class="o">!</span><span class="nx">savedNonce</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">UnauthorizedException</span><span class="p">(</span>
        <span class="dl">"</span><span class="s2">로그인 세션이 만료되었습니다. 다시 시도해주세요.</span><span class="dl">"</span><span class="p">,</span>
      <span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// A. State 검증 (CSRF 방지)</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">savedState</span> <span class="o">!==</span> <span class="nx">requestState</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">UnauthorizedException</span><span class="p">(</span><span class="dl">"</span><span class="s2">유효하지 않은 인증 상태(state)입니다.</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// B. 구글 토큰 발급 (ID Token 포함)</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">id_token</span> <span class="p">}</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nf">exchangeCodeForTokens</span><span class="p">(</span><span class="nx">code</span><span class="p">);</span>

    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">id_token</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">UnauthorizedException</span><span class="p">(</span><span class="dl">"</span><span class="s2">구글 ID 토큰이 발급되지 않았습니다.</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// C. ID Token 검증 및 nonce 확인 (재전송 공격 방지)</span>
    <span class="kd">const</span> <span class="nx">googlePayload</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nf">verifyGoogleIdToken</span><span class="p">(</span><span class="nx">id_token</span><span class="p">);</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">googlePayload</span><span class="p">.</span><span class="nx">nonce</span> <span class="o">!==</span> <span class="nx">savedNonce</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">UnauthorizedException</span><span class="p">(</span>
        <span class="dl">"</span><span class="s2">ID 토큰 보안 검증(nonce)에 실패했습니다.</span><span class="dl">"</span><span class="p">,</span>
      <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">googlePayload</span><span class="p">.</span><span class="nx">email_verified</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">UnauthorizedException</span><span class="p">(</span>
        <span class="dl">"</span><span class="s2">구글 이메일 인증이 완료되지 않았습니다.</span><span class="dl">"</span><span class="p">,</span>
      <span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// D. 우리 서비스 유저 처리 (회원가입 또는 로그인)</span>
    <span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">userService</span><span class="p">.</span><span class="nf">createSocialUser</span><span class="p">({</span>
      <span class="na">email</span><span class="p">:</span> <span class="nx">googlePayload</span><span class="p">.</span><span class="nx">email</span><span class="p">,</span>
      <span class="na">nickname</span><span class="p">:</span> <span class="nx">googlePayload</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span>
      <span class="na">socialId</span><span class="p">:</span> <span class="nx">googlePayload</span><span class="p">.</span><span class="nx">sub</span><span class="p">,</span>
      <span class="na">profileImageUrl</span><span class="p">:</span> <span class="nx">googlePayload</span><span class="p">.</span><span class="nx">picture</span><span class="p">,</span>
      <span class="na">provider</span><span class="p">:</span> <span class="dl">"</span><span class="s2">GOOGLE</span><span class="dl">"</span><span class="p">,</span>
    <span class="p">});</span>

    <span class="kd">const</span> <span class="nx">sub</span> <span class="o">=</span> <span class="nx">user</span><span class="p">.</span><span class="nf">getId</span><span class="p">().</span><span class="nf">getValue</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">email</span> <span class="o">=</span> <span class="nx">user</span><span class="p">.</span><span class="nf">getEmail</span><span class="p">().</span><span class="nf">getValue</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">role</span> <span class="o">=</span> <span class="nx">user</span><span class="p">.</span><span class="nf">getRole</span><span class="p">().</span><span class="nf">getValue</span><span class="p">();</span>

    <span class="kd">const</span> <span class="na">accessTokenPayload</span><span class="p">:</span> <span class="nx">IAccessTokenPayload</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">sub</span><span class="p">,</span>
      <span class="nx">email</span><span class="p">,</span>
      <span class="nx">role</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="kd">const</span> <span class="na">refreshTokenPayload</span><span class="p">:</span> <span class="nx">IRefreshTokenPayload</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">sub</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="c1">// E. 자체 서비스 토큰 발급</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">accessToken</span><span class="p">,</span> <span class="nx">refreshToken</span><span class="p">]</span> <span class="o">=</span> <span class="k">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nf">all</span><span class="p">([</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">tokenService</span><span class="p">.</span><span class="nf">generateAccessToken</span><span class="p">(</span><span class="nx">accessTokenPayload</span><span class="p">),</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">tokenService</span><span class="p">.</span><span class="nf">generateRefreshToken</span><span class="p">(</span><span class="nx">refreshTokenPayload</span><span class="p">),</span>
    <span class="p">]);</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`구글 로그인이 성공적으로 완료되었습니다: </span><span class="p">${</span><span class="nx">email</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nc">LoginResponseDto</span><span class="p">(</span><span class="nx">accessToken</span><span class="p">,</span> <span class="nx">refreshToken</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/**
   * 구글 서버에 Code를 주고 ID Token을 받아옴
   */</span>
  <span class="k">private</span> <span class="k">async</span> <span class="nf">exchangeCodeForTokens</span><span class="p">(</span><span class="nx">code</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">Credentials</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">구글 서버와 인가 코드를 토큰으로 교환합니다.</span><span class="dl">"</span><span class="p">);</span>

    <span class="k">try</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="p">{</span> <span class="nx">tokens</span> <span class="p">}</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">googleClient</span><span class="p">.</span><span class="nf">getToken</span><span class="p">(</span><span class="nx">code</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">tokens</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">errorMessage</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">구글 토큰 발급에 실패했습니다.</span><span class="dl">"</span><span class="p">;</span>

      <span class="k">if </span><span class="p">(</span><span class="nx">error</span> <span class="k">instanceof</span> <span class="nb">Error</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// google-auth-library는 에러 발생 시 response data를 포함할 수 있습니다.</span>
        <span class="kd">const</span> <span class="nx">responseData</span> <span class="o">=</span> <span class="p">(</span><span class="nx">error</span> <span class="k">as</span> <span class="kr">any</span><span class="p">).</span><span class="nx">response</span><span class="p">?.</span><span class="nx">data</span><span class="p">;</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">responseData</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">warn</span><span class="p">(</span>
            <span class="s2">`구글 토큰 교환 실패 상세: </span><span class="p">${</span><span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">(</span><span class="nx">responseData</span><span class="p">)}</span><span class="s2">`</span><span class="p">,</span>
          <span class="p">);</span>
          <span class="nx">errorMessage</span> <span class="o">=</span> <span class="s2">`구글 토큰 교환 실패: </span><span class="p">${</span><span class="nx">responseData</span><span class="p">.</span><span class="nx">error_description</span> <span class="o">||</span> <span class="nx">error</span><span class="p">.</span><span class="nx">message</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="nx">errorMessage</span> <span class="o">=</span> <span class="s2">`구글 토큰 교환 실패: </span><span class="p">${</span><span class="nx">error</span><span class="p">.</span><span class="nx">message</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="k">throw</span> <span class="k">new</span> <span class="nc">UnauthorizedException</span><span class="p">(</span><span class="nx">errorMessage</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/**
   * 구글 ID 토큰 검증
   */</span>
  <span class="k">private</span> <span class="k">async</span> <span class="nf">verifyGoogleIdToken</span><span class="p">(</span><span class="nx">idToken</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">TokenPayload</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">구글 ID 토큰을 검증합니다.</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">ticket</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">googleClient</span><span class="p">.</span><span class="nf">verifyIdToken</span><span class="p">({</span>
        <span class="nx">idToken</span><span class="p">,</span>
        <span class="na">audience</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">appConfigService</span><span class="p">.</span><span class="nx">googleClientId</span><span class="p">,</span>
      <span class="p">});</span>

      <span class="kd">const</span> <span class="nx">payload</span> <span class="o">=</span> <span class="nx">ticket</span><span class="p">.</span><span class="nf">getPayload</span><span class="p">();</span>
      <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">payload</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">ID 토큰 페이로드가 비어있습니다.</span><span class="dl">"</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="k">return</span> <span class="nx">payload</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">UnauthorizedException</span><span class="p">(</span>
        <span class="s2">`구글 ID 토큰 검증 실패: </span><span class="p">${</span><span class="nx">error</span> <span class="k">instanceof</span> <span class="nb">Error</span> <span class="p">?</span> <span class="nx">error</span><span class="p">.</span><span class="nx">message</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">알 수 없는 오류</span><span class="dl">"</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
      <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>구글 ID 토큰 검증 단계는 <a href="https://developers.google.com/identity/openid-connect/openid-connect?hl=ko#validatinganidtoken">ID 토큰 검증 가이드</a>를 참고하시면 되며, 필자는 <a href="https://developers.google.com/identity/gsi/web/guides/verify-google-id-token?hl=ko#using-a-google-api-client-library">Google API 클라이언트 라이브러리</a>를 사용하여 구현했습니다.</p>
</blockquote>

<p><br />
이제 코드를 단계별로 살펴보겠습니다.
<br />
<br />
<b>A. State 검증</b></p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A. State 검증 (CSRF 방지)</span>
<span class="k">if </span><span class="p">(</span><span class="nx">savedState</span> <span class="o">!==</span> <span class="nx">requestState</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nc">UnauthorizedException</span><span class="p">(</span><span class="dl">"</span><span class="s2">유효하지 않은 인증 상태(state)입니다.</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>먼저 <code class="language-plaintext highlighter-rouge">GET /auth/google</code> 엔드포인트에서 쿠키에 저장했던 <code class="language-plaintext highlighter-rouge">savedState</code> 값과 클라이언트로부터 받은 <code class="language-plaintext highlighter-rouge">requestState</code> 값을 비교합니다. 만약 두 값이 일치하지 않는다면 CSRF 공격일 가능성이 있으므로 예외를 던집니다.
<br />
<br />
<b>B. 구글 ID 토큰 발급</b></p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// B. 구글 토큰 발급 (ID Token 포함)</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">id_token</span> <span class="p">}</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nf">exchangeCodeForTokens</span><span class="p">(</span><span class="nx">code</span><span class="p">);</span>

<span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">id_token</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nc">UnauthorizedException</span><span class="p">(</span><span class="dl">"</span><span class="s2">구글 ID 토큰이 발급되지 않았습니다.</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">exchangeCodeForTokens()</code> 메서드를 호출하여 구글 인증 서버에 인가 코드를 전달하고 ID 토큰과 액세스 토큰을 발급받습니다.
<br />
<br />
<b>C. ID 토큰 검증 및 nonce 확인</b></p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// C. ID Token 검증 및 nonce 확인 (재전송 공격 방지)</span>
<span class="kd">const</span> <span class="nx">googlePayload</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nf">verifyGoogleIdToken</span><span class="p">(</span><span class="nx">id_token</span><span class="p">);</span>

<span class="k">if </span><span class="p">(</span><span class="nx">googlePayload</span><span class="p">.</span><span class="nx">nonce</span> <span class="o">!==</span> <span class="nx">savedNonce</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nc">UnauthorizedException</span><span class="p">(</span>
    <span class="dl">"</span><span class="s2">ID 토큰 보안 검증(nonce)에 실패했습니다.</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">googlePayload</span><span class="p">.</span><span class="nx">email_verified</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nc">UnauthorizedException</span><span class="p">(</span>
    <span class="dl">"</span><span class="s2">구글 이메일 인증이 완료되지 않았습니다.</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">verifyGoogleIdToken()</code> 메서드를 호출하여 구글로부터 받은 ID 토큰을 검증하고, 토큰의 페이로드를 가져옵니다.<br />
그 후에 페이로드에 포함된 <code class="language-plaintext highlighter-rouge">nonce</code> 값과 쿠키에 저장했던 <code class="language-plaintext highlighter-rouge">savedNonce</code> 값을 비교하여 재전송 공격을 방지합니다.<br />
또한, 구글 이메일 인증이 완료되었는지도 확인합니다.
<br />
<br />
<b>D. 우리 서비스 유저 처리</b></p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// D. 우리 서비스 유저 처리 (회원가입 또는 로그인)</span>
<span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">userService</span><span class="p">.</span><span class="nf">createSocialUser</span><span class="p">({</span>
  <span class="na">email</span><span class="p">:</span> <span class="nx">googlePayload</span><span class="p">.</span><span class="nx">email</span><span class="p">,</span>
  <span class="na">nickname</span><span class="p">:</span> <span class="nx">googlePayload</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span>
  <span class="na">socialId</span><span class="p">:</span> <span class="nx">googlePayload</span><span class="p">.</span><span class="nx">sub</span><span class="p">,</span>
  <span class="na">profileImageUrl</span><span class="p">:</span> <span class="nx">googlePayload</span><span class="p">.</span><span class="nx">picture</span><span class="p">,</span>
  <span class="na">provider</span><span class="p">:</span> <span class="dl">"</span><span class="s2">GOOGLE</span><span class="dl">"</span><span class="p">,</span>
<span class="p">});</span>
</code></pre></div></div>

<p>ID 토큰에서 추출한 사용자 정보를 바탕으로 <code class="language-plaintext highlighter-rouge">UserService</code>의 <code class="language-plaintext highlighter-rouge">createSocialUser()</code> 메서드를 호출하여 우리 서비스의 유저를 생성하거나 기존 유저를 조회합니다.
<br />
<br />
<b>E. 자체 서비스 토큰 발급</b></p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// E. 자체 서비스 토큰 발급</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">accessToken</span><span class="p">,</span> <span class="nx">refreshToken</span><span class="p">]</span> <span class="o">=</span> <span class="k">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nf">all</span><span class="p">([</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">tokenService</span><span class="p">.</span><span class="nf">generateAccessToken</span><span class="p">(</span><span class="nx">accessTokenPayload</span><span class="p">),</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">tokenService</span><span class="p">.</span><span class="nf">generateRefreshToken</span><span class="p">(</span><span class="nx">refreshTokenPayload</span><span class="p">),</span>
<span class="p">]);</span>

<span class="k">this</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`구글 로그인이 성공적으로 완료되었습니다: </span><span class="p">${</span><span class="nx">email</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>

<span class="k">return</span> <span class="k">new</span> <span class="nc">LoginResponseDto</span><span class="p">(</span><span class="nx">accessToken</span><span class="p">,</span> <span class="nx">refreshToken</span><span class="p">);</span>
</code></pre></div></div>

<p>마지막으로 자체 서비스 토큰(JWT)을 발급한 후 반환합니다.</p>

<h2 id="프론트엔드에서-필요한-작업">프론트엔드에서 필요한 작업</h2>

<p>저는 이번 포스팅에서 백엔드 구현에 집중했기에 프론트엔드 코드는 다루지 않았습니다.<br />
혹여나 필요한 분들을 위해 간단히 프론트엔드에서 필요한 작업에 대해서 말해보자면 아래와 같습니다.
<br /></p>
<ol>
  <li>구글 로그인 버튼을 클릭했을 때 <code class="language-plaintext highlighter-rouge">GET /auth/google</code> API로 요청을 보내는 로직이 필요합니다.</li>
  <li>구글 인증이 완료된 후 콜백 URL(http://localhost:5173/google-callback)에서 인가 코드와 <code class="language-plaintext highlighter-rouge">state</code> 값을 받아 <code class="language-plaintext highlighter-rouge">POST /auth/google/authenticate</code> API로 전달하는 작업이 필요합니다.</li>
</ol>

<h2 id="구글-로그인-테스트하기">구글 로그인 테스트하기</h2>

<p>이제 모든 구현이 완료되었으니 제가 만든 서비스에서 구글 로그인을 테스트해보겠습니다.<br />
로그인 페이지에서 구글 로그인 버튼을 클릭합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/google-login-button.png" alt="Google Login Button" />
<br />
<br />
구글 로그인 버튼을 클릭하면 <code class="language-plaintext highlighter-rouge">GET /auth/google</code> API가 호출되고, 클라이언트는 구글 인증 페이지로 리다이렉트됩니다.
<br />
<br />
구글 로그인 페이지에서 원하는 계정을 선택하고 권한을 승인합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/google-grant-permission.png" alt="Google Grant Permission" />
<br />
<br />
승인 후에는 다시 클라이언트의 콜백 URL로 리다이렉트되고, 인가 코드와 <code class="language-plaintext highlighter-rouge">state</code> 값이 포함되어 있을겁니다.<br />
프론트엔드에선 이 값을 추출하여 <code class="language-plaintext highlighter-rouge">POST /auth/google/authenticate</code> API로 전달합니다.<br />
그 결과 응답값으로 서비스 토큰(액세스 토큰, 리프레시 토큰)을 받게 되고, 이를 통해 서비스에 로그인된 상태가 됩니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/google-login-success.png" alt="Google Login Success" /></p>

<h2 id="마치며">마치며</h2>

<p>이렇게 해서 Nest.js 환경에서 OIDC를 사용하여 구글 로그인 구현을 완료했습니다.</p>

<p class="note">전체 코드가 궁금하신 분들은 <a href="https://github.com/NicoDora/sift-backend/blob/develop/src/modules/auth/presentation/auth.controller.ts">여기</a>를 참고해주세요.</p>

<p>아래부터는 제가 구글 로그인을 구현하면서 마주한 문제들과 그에 대한 생각을 정리해 보았으니 로그인 구현을 마치셨다면 한번쯤 읽어보시면 좋을 것 같습니다.</p>

<p>그럼 다음 포스트에서 뵙겠습니다! 뾰로롱~
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/frieren1.gif" width="300" height="300" alt="프리렌 움짤1" /></p>

<h3 id="state-값-저장방식-쿠키-vs-서버">state 값 저장방식 (쿠키 vs 서버)</h3>

<p><code class="language-plaintext highlighter-rouge">state</code> 값을 저장하는 이유는 CSRF 공격을 방지하기 위함인데, 제가 구현한 방식을 보다보면 이런 생각이 들 수 있습니다.<br />
“<code class="language-plaintext highlighter-rouge">state</code> 값을 클라이언트 쿠키에 저장하지 않고, 서버 세션이나 인메모리 캐시(Redis 등)에 저장하는게 더 안전하지 않을까?”<br />
서버 세션이나 인메모리 캐시에 저장하는 방법이 보안상 더 안전할 수 있지만, 서버에 저장하게 된다면 다음과 같은 문제점이 발생할 수 있습니다.
<br />
<br />
먼저 서버에서 <code class="language-plaintext highlighter-rouge">state</code> 값을 관리해야 하므로 추가적인 저장소가 필요합니다. 그리고 로그인이 한번의 API 요청으로 완료되는게 아니라 두 단계로 나누어지기 때문에, 후에 토큰 발급 요청을 보내는 클라이언트가 이전에 로그인 요청을 보낸 클라이언트와 동일한지 확인하기 위해 세션 식별자나 기타 식별자를 함께 관리해야 합니다.
<br />
<br />
세션 식별자는 쿠키에 저장되기 때문에 결국 쿠키를 사용하여 클라이언트에 정보를 저장하게 되고, 서버에서 세션을 관리해야 하는 추가적인 복잡성이 발생합니다. 그리고 OAuth 인증 흐름에서는 stateless(무상태성)를 유지하는 것이 권장되기 때문에, 서버에서 상태를 관리하는 것은 이러한 원칙에 어긋날 수 있습니다. (서버가 여러 대일 경우 상태 동기화 작업도 해줘야 합니다.)
<br />
<br />
따라서 <code class="language-plaintext highlighter-rouge">state</code> 값을 클라이언트 쿠키에 저장하는 방식이 더 간단하게 구현할 수 있고 OAuth의 무상태성 원칙에도 부합한다고 생각하여 쿠키에 저장하는 방식을 선택했습니다.</p>

<h3 id="인가-코드-콜백은-어디로-클라이언트-vs-서버">인가 코드 콜백은 어디로? (클라이언트 vs 서버)</h3>

<p>대부분의 글이나 예제를 살펴보면 인가 코드 콜백 URL을 서버로 지정하는 경우가 많습니다.<br />
실제로 구글의 <a href="https://developers.google.com/identity/openid-connect/openid-connect?hl=ko#server-flow">OIDC 서버 흐름</a> 문서에서도 콜백 URL을 서버로 지정하고 있습니다.
<br />
<br />
그러나 이렇게 콜백 URL을 서버로 지정하게 되면 서버에서 다시 클라이언트로 리다이렉트 시켜주는 추가적인 작업이 필요합니다.<br />
즉, 302 응답을 보내게 된다는 것인데 브라우저는 302 응답을 받으면 <code class="language-plaintext highlighter-rouge">Body</code>를 읽기 전에 <code class="language-plaintext highlighter-rouge">Location</code> 헤더에 적힌 주소로 즉시 이동(Redirect)해 버립니다.
<br />
<br />
쿠키로 서비스 토큰을 전달할 수 있지만 저희 서비스에선 액세스 토큰은 <code class="language-plaintext highlighter-rouge">localStorage</code>에, 리프레시 토큰은 쿠키에 저장하는 방식을 사용하고 싶었기 때문에 어떤 방법을 써야할지 고민했습니다.
<br />
<br />
가장 간단한 방법으론 액세스 토큰을 URL 파라미터에 포함시키는 방법이 있겠지만, URL에 민감한 정보를 담는 것은 보안상 좋지 않기에 이 방법은 제외했고, 또 다른 방법으로는 액세스 토큰도 <code class="language-plaintext highlighter-rouge">httpOnly</code> 옵션을 끈 쿠키에 임시 저장하여 클라이언트에서 이를 읽은 뒤 즉시 삭제하는 방법을 생각해봤습니다. 그러나 이 역시 보안상 좋지 않고 클라이언트에서 불필요한 작업이 추가된다는 단점이 있었습니다.
<br />
<br />
그래서 저는 인가 코드 콜백 URL을 클라이언트로 지정하는 방식을 선택했습니다.<br />
중간에 클라이언트가 요청을 보내는 작업이 추가되긴 하지만, 제가 원하는대로 <code class="language-plaintext highlighter-rouge">Body</code>에 액세스 토큰을 실어 보낼 수 있고, 실제 구글과 통신하여 토큰을 바꾸고 유효성을 검증하는 모든 권한과 로직은 서버에 있기 때문에 서버 주도 방식 (Server-side Flow)을 유지할 수 있었기 때문입니다.</p>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://developers.google.com/identity/openid-connect/openid-connect?hl=ko">OpenID Connect</a></li>
  <li><a href="https://oauth.net/articles/authentication/">User Authentication with OAuth 2.0</a></li>
  <li><a href="https://developers.google.com/oauthplayground/">Google OAuth 2.0 Playground</a></li>
  <li><a href="https://openid.net/specs/openid-connect-core-1_0-final.html#StandardClaims">OpenID Connect Core 1.0</a></li>
  <li><a href="https://developers.google.com/identity/openid-connect/openid-connect?hl=ko#an-id-tokens-payload">ID 토큰의 페이로드</a></li>
  <li><a href="https://developers.google.com/identity/openid-connect/openid-connect?hl=ko#validatinganidtoken">ID 토큰 검증</a></li>
  <li><a href="https://developers.google.com/identity/gsi/web/guides/verify-google-id-token?hl=ko">서버 측에서 Google ID 토큰 확인</a></li>
</ul>]]></content><author><name>NicoDora</name></author><category term="nestjs" /><summary type="html"><![CDATA[Nest.js에서 Google OAuth2.0 (OIDC) 로그인을 구현하는 방법에 대해 알아보겠습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/oauth-vs-oidc.png" /><media:content medium="image" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2026-01-15-Nestjs-Google-OAuth20-로그인-구현하기/oauth-vs-oidc.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">[Nest.js] websocket 클라이언트로 ack 보내기</title><link href="http://localhost:4000/nestjs/Nest.js-websocket-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%A1%9C-ack-%EB%B3%B4%EB%82%B4%EA%B8%B0/" rel="alternate" type="text/html" title="[Nest.js] websocket 클라이언트로 ack 보내기" /><published>2025-03-24T20:00:00+09:00</published><updated>2025-03-24T20:00:00+09:00</updated><id>http://localhost:4000/nestjs/%5BNest.js%5D-websocket-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%A1%9C-ack-%EB%B3%B4%EB%82%B4%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/nestjs/Nest.js-websocket-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%A1%9C-ack-%EB%B3%B4%EB%82%B4%EA%B8%B0/"><![CDATA[<ol id="markdown-toc">
  <li><a href="#문제" id="markdown-toc-문제">문제</a></li>
  <li><a href="#해결방법-ack-보내기" id="markdown-toc-해결방법-ack-보내기">해결방법 (ack 보내기)</a></li>
  <li><a href="#마치며" id="markdown-toc-마치며">마치며</a></li>
</ol>

<h2 id="문제">문제</h2>

<p>프로젝트에서 웹소켓을 사용해서 1대1 채팅을 구현하고 있었는데 일단 코드는 이렇게 구현했었는데요.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nc">ChatMessageGateway</span>
  <span class="k">implements</span> <span class="nx">OnGatewayConnection</span><span class="p">,</span> <span class="nx">OnGatewayDisconnect</span>
<span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span>
    <span class="p">@</span><span class="nd">Inject</span><span class="p">(</span><span class="nx">CHAT_ROOM_REPOSITORY_DI_TOKEN</span><span class="p">)</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">chatRoomRepository</span><span class="p">:</span> <span class="nx">ChatRoomRepositoryPort</span><span class="p">,</span>
    <span class="p">@</span><span class="nd">Inject</span><span class="p">(</span><span class="nx">APP_JWT_SERVICE_DI_TOKEN</span><span class="p">)</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">appJwtService</span><span class="p">:</span> <span class="nx">AppJwtServicePort</span><span class="p">,</span>
    <span class="p">@</span><span class="nd">Inject</span><span class="p">(</span><span class="nx">WINSTON_MODULE_NEST_PROVIDER</span><span class="p">)</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">logger</span><span class="p">:</span> <span class="nx">Logger</span><span class="p">,</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">commandBus</span><span class="p">:</span> <span class="nx">CommandBus</span><span class="p">,</span>
  <span class="p">)</span> <span class="p">{}</span>

  <span class="p">@</span><span class="nd">WebSocketServer</span><span class="p">()</span>
  <span class="nx">server</span><span class="p">:</span> <span class="nx">Server</span><span class="p">;</span>

  <span class="k">async</span> <span class="nf">handleConnection</span><span class="p">(</span><span class="nx">socket</span><span class="p">:</span> <span class="nx">SocketWithUserDto</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>

  <span class="k">async</span> <span class="nf">handleDisconnect</span><span class="p">(</span><span class="nx">socket</span><span class="p">:</span> <span class="nx">SocketWithUserDto</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>

  <span class="p">@</span><span class="nd">UsePipes</span><span class="p">(</span><span class="nx">customValidationPipe</span><span class="p">)</span>
  <span class="p">@</span><span class="nd">UseFilters</span><span class="p">(</span><span class="nx">SocketCatchHttpExceptionFilter</span><span class="p">)</span>
  <span class="p">@</span><span class="nd">SubscribeMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">enter_chat_room</span><span class="dl">'</span><span class="p">)</span>
  <span class="k">async</span> <span class="nf">enterChat</span><span class="p">(</span>
    <span class="p">@</span><span class="nd">MessageBody</span><span class="p">()</span> <span class="nx">data</span><span class="p">:</span> <span class="nx">EnterChatDto</span><span class="p">,</span>
    <span class="p">@</span><span class="nd">ConnectedSocket</span><span class="p">()</span> <span class="nx">socket</span><span class="p">:</span> <span class="nx">SocketWithUserDto</span><span class="p">,</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">roomId</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>

    <span class="kd">const</span> <span class="nx">chatRoom</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">chatRoomRepository</span><span class="p">.</span><span class="nf">findOneById</span><span class="p">(</span><span class="nx">roomId</span><span class="p">);</span>

    <span class="k">if </span><span class="p">(</span><span class="nf">isNil</span><span class="p">(</span><span class="nx">chatRoom</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span>
        <span class="s2">`[Socket] enter_chat_room failed: Room </span><span class="p">${</span><span class="nx">roomId</span><span class="p">}</span><span class="s2"> does not exist`</span><span class="p">,</span>
      <span class="p">);</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">WsException</span><span class="p">(</span><span class="dl">'</span><span class="s1">Does not exist room</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">socket</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nc">String</span><span class="p">(</span><span class="nx">roomId</span><span class="p">));</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`[Socket] User </span><span class="p">${</span><span class="nx">socket</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">sub</span><span class="p">}</span><span class="s2"> joined room </span><span class="p">${</span><span class="nx">roomId</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">@</span><span class="nd">UsePipes</span><span class="p">(</span><span class="nx">customValidationPipe</span><span class="p">)</span>
  <span class="p">@</span><span class="nd">UseFilters</span><span class="p">(</span><span class="nx">SocketCatchHttpExceptionFilter</span><span class="p">)</span>
  <span class="p">@</span><span class="nd">SubscribeMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">send_message</span><span class="dl">'</span><span class="p">)</span>
  <span class="k">async</span> <span class="nf">sendMessage</span><span class="p">(</span>
    <span class="p">@</span><span class="nd">MessageBody</span><span class="p">()</span> <span class="nx">data</span><span class="p">:</span> <span class="nx">CreateChatMessageDto</span><span class="p">,</span>
    <span class="p">@</span><span class="nd">ConnectedSocket</span><span class="p">()</span> <span class="nx">socket</span><span class="p">:</span> <span class="nx">SocketWithUserDto</span><span class="p">,</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">roomId</span><span class="p">,</span> <span class="nx">message</span><span class="p">,</span> <span class="nx">blogPostUrl</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="na">sub</span><span class="p">:</span> <span class="nx">userId</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">socket</span><span class="p">.</span><span class="nx">user</span><span class="p">;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
      <span class="s2">`[Socket] Received message from </span><span class="p">${</span><span class="nx">userId</span><span class="p">}</span><span class="s2"> in room </span><span class="p">${</span><span class="nx">roomId</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">message</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="kd">const</span> <span class="nx">command</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CreateChatMessageCommand</span><span class="p">({</span>
      <span class="na">roomId</span><span class="p">:</span> <span class="nc">BigInt</span><span class="p">(</span><span class="nx">roomId</span><span class="p">),</span>
      <span class="na">userId</span><span class="p">:</span> <span class="nc">BigInt</span><span class="p">(</span><span class="nx">userId</span><span class="p">),</span>
      <span class="nx">message</span><span class="p">,</span>
      <span class="nx">blogPostUrl</span><span class="p">,</span>
    <span class="p">});</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
      <span class="s2">`[Socket] Sending message from </span><span class="p">${</span><span class="nx">userId</span><span class="p">}</span><span class="s2"> in room </span><span class="p">${</span><span class="nx">roomId</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">message</span><span class="p">}</span><span class="s2">, </span><span class="p">${</span><span class="nx">blogPostUrl</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">commandBus</span><span class="p">.</span><span class="nx">execute</span><span class="o">&lt;</span><span class="nx">CreateChatMessageCommand</span><span class="p">,</span> <span class="k">void</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">command</span><span class="p">);</span>

    <span class="nx">socket</span>
      <span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="nc">String</span><span class="p">(</span><span class="nx">roomId</span><span class="p">))</span>
      <span class="p">.</span><span class="nf">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">receive_message</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">senderId</span><span class="p">:</span> <span class="nx">userId</span><span class="p">,</span> <span class="nx">message</span><span class="p">,</span> <span class="nx">blogPostUrl</span> <span class="p">});</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
      <span class="s2">`[Socket] Message emitted to room </span><span class="p">${</span><span class="nx">roomId</span><span class="p">}</span><span class="s2"> from </span><span class="p">${</span><span class="nx">userId</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p><br />
<br />
postman에서 <code class="language-plaintext highlighter-rouge">enter_chat_room</code> 이벤트와 <code class="language-plaintext highlighter-rouge">send_message</code> 이벤트를 테스트 해보면 결과는 아래와 같습니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2025-03-24-Nestjs-websocket-클라이언트로-ack-보내기/enter-chat-room-test.png" alt="enter-chat-room-테스트" />
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2025-03-24-Nestjs-websocket-클라이언트로-ack-보내기/send-message-test.png" alt="send-message-테스트" />
<br />
<br />
postman에서는 이벤트 결과를 확인할 수 있지만 실제로 클라이언트에서는 이벤트 결과를 확인하기 힘들다고 하더라구요. 소켓 통신 테스트 과정에서 <code class="language-plaintext highlighter-rouge">send_message</code> 이벤트를 보냈을 때 메시지가 전송되지 않는 문제가 있었는데 이게 채팅방에 입장이 안된건지, 진짜 메시지가 전송이 안된건지 확인하기 힘들었습니다.
<br />
<br />
그래서 웹소켓에서도 http 요청처럼 응답을 보낼 수 있는 방법이 있나 찾아보다가 ack(acknowledgement)를 응답으로 보내는 방법을 발견하게 되었습니다.</p>

<h2 id="해결방법-ack-보내기">해결방법 (ack 보내기)</h2>

<p>ack를 보내게 되면 클라이언트에서 callback 함수를 통해서 응답을 받을 수 있습니다.<br />
ack를 보내는 방법은 생각보다 간단했습니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2025-03-24-Nestjs-websocket-클라이언트로-ack-보내기/add-ack.png" alt="ack-보내기" />
<br />
<br />
그냥 이렇게 이벤트 함수 안에 return값을 추가해주면 됩니다!
<br />
<br />
클라이언트에선 callback 함수를 통해서 ack를 확인할 수 있는데, 일단 코드를 커밋하기 전에 postman에서 테스트를 해봐야겠죠?<br />
postman에서 ack를 받는 방법도 엄청 간단합니다. 그냥 <code class="language-plaintext highlighter-rouge">Ack</code> 버튼을 눌러 활성화해주면 됩니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2025-03-24-Nestjs-websocket-클라이언트로-ack-보내기/postman-ack-check.png" alt="postman-ack-테스트" />
<br />
<br />
이제 postman에서 <code class="language-plaintext highlighter-rouge">enter_chat_room</code> 이벤트를 테스트 해보면 아래와 같이 ack를 받을 수 있습니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2025-03-24-Nestjs-websocket-클라이언트로-ack-보내기/ack-test.png" alt="ack-테스트" /></p>

<h2 id="마치며">마치며</h2>

<p>ack를 보내게 되면 클라이언트 입장에서 메시지가 전송이 되었는지 확인할 수 있기 때문에 소켓 통신을 테스트할 때 유용하게 사용할 수 있을거 같습니다.
<br />
<br />
그럼 다음 포스트에서 뵙겠습니다! 뾰로롱~
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/frieren1.gif" width="300" height="300" alt="프리렌 움짤1" /></p>]]></content><author><name>NicoDora</name></author><category term="nestjs" /><summary type="html"><![CDATA[NestJS의 websocket 라이브러리를 사용해 웹소켓을 구현할 때 클라이언트로 ack를 보내는 방법을 알아봅시다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2025-03-24-Nestjs-websocket-클라이언트로-ack-보내기/send-ack.png" /><media:content medium="image" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2025-03-24-Nestjs-websocket-클라이언트로-ack-보내기/send-ack.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">GitHub Actions로 CI/CD 구축하기</title><link href="http://localhost:4000/github/GitHub-Actions%EB%A1%9C-CICD-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="GitHub Actions로 CI/CD 구축하기" /><published>2025-03-18T18:03:00+09:00</published><updated>2025-03-18T18:03:00+09:00</updated><id>http://localhost:4000/github/GitHub-Actions%EB%A1%9C-CICD-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/github/GitHub-Actions%EB%A1%9C-CICD-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0/"><![CDATA[<ol id="markdown-toc">
  <li><a href="#지금까지의-이야기" id="markdown-toc-지금까지의-이야기">지금까지의 이야기</a></li>
  <li><a href="#cicd란" id="markdown-toc-cicd란">CI/CD란?</a></li>
  <li><a href="#actions-secrets-설정하기" id="markdown-toc-actions-secrets-설정하기">Actions Secrets 설정하기</a></li>
  <li><a href="#github-actions-workflow-생성하기" id="markdown-toc-github-actions-workflow-생성하기">GitHub Actions Workflow 생성하기</a></li>
  <li><a href="#github-actions-실행-확인하기" id="markdown-toc-github-actions-실행-확인하기">GitHub Actions 실행 확인하기</a></li>
  <li><a href="#마치며" id="markdown-toc-마치며">마치며</a></li>
</ol>

<h2 id="지금까지의-이야기">지금까지의 이야기</h2>

<p>이전 포스팅에서 AWS EC2에 Nginx와 Certbot을 설치하여 Let’s Encrypt SSL 인증서를 발급 및 자동 갱신까지 하는 방법에 대해 알아보았습니다. 서버를 구축하고 어느정도 사용해보시면 알겠지만, 서버 코드가 수정될 때 마다 수동으로 EC2에 접속하여 컨테이너를 내리고 수정된 코드를 이미지로 만들어 다시 컨테이너를 실행시키는 작업이 매우 비효율적이라는 것을 깨닫게 됩니다.
<br />
<br />
몇번 이 작업을 반복하다보면, ‘이 작업을 자동화 하면 좋겠다’ 하는 생각이 드실겁니다.<br />
보통 이러한 과정을 CI/CD라고 부르고, GitHub에서는 Actions라는 서비스를 통해 개발자들이 편하게 CI/CD를 구축할 수 있도록 환경을 제공하고 있습니다. 이번 포스팅에서는 GitHub Actions를 사용하여 CI/CD를 구축하는 방법에 대해 알아보겠습니다.</p>

<h2 id="cicd란">CI/CD란?</h2>

<p>CI/CD는 ‘Continuous Integration/Continuous Delivery’의 약자로, 지속적인 통합과 지속적인 배포를 의미합니다. 즉, 코드 변경 사항을 자동으로 빌드하고 테스트하여 배포하는 과정을 자동화한다 라고 생각하시면 됩니다.</p>

<ul>
  <li><b>CI (Continuous Integration) - 지속적인 통합</b>
    <ul>
      <li>개발자들이 작성한 코드를 정기적으로 통합하여 빌드하고 테스트하는 과정입니다. 이를 통해 코드의 품질을 높이고, 버그를 조기에 발견할 수 있습니다.</li>
    </ul>
  </li>
  <li><b>CD (Continuous Delivery) - 지속적인 배포</b>
    <ul>
      <li>CI 과정에서 빌드된 코드를 자동으로 배포하는 과정입니다. 이를 통해 코드 변경 사항을 빠르게 사용자에게 전달할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<p><br />
GitHub Actions는 이러한 CI/CD를 구현하기 위한 도구로, GitHub 저장소에서 직접 워크플로우를 정의하고 실행할 수 있습니다. GitHub는 개발자가 가장 많이 사용하는 서비스 중 하나이기 때문에 GitHub Actions에 대해 배우는 것은 크게 어렵지 않으실 겁니다.</p>

<h2 id="actions-secrets-설정하기">Actions Secrets 설정하기</h2>

<p>GitHub Actions를 사용하기 전에 먼저 GitHub 저장소에 <code class="language-plaintext highlighter-rouge">Secrets</code>를 설정해보려 합니다. GitHub Actions는 GitHub repository에 올린 <code class="language-plaintext highlighter-rouge">workflow/</code> 폴더 내의 파일을 통해 CI/CD를 실행하게 되는데 여기서 Docker ID/PW나 AWS EC2에 SSH로 접속하기 위한 비밀번호 등과 같이 민감한 정보가 필요합니다.
<br />
<br />
GitHub에서는 이러한 민감한 정보를 <code class="language-plaintext highlighter-rouge">Secrets</code>라는 기능을 통해 안전하게 저장하고 사용할 수 있도록 지원하고 있습니다.
<br />
<br />
GitHub Secrets는 GitHub repository의 <code class="language-plaintext highlighter-rouge">Settings</code> &gt; <code class="language-plaintext highlighter-rouge">Secrets and variables</code> &gt; <code class="language-plaintext highlighter-rouge">Actions</code>에서 설정할 수 있습니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets.png" alt="GitHub Secrets 접속" />
<br />
<br /></p>

<p><code class="language-plaintext highlighter-rouge">Secrets</code> 탭에서 시크릿 환경변수를 관리할 수 있는데요. 여기서 <code class="language-plaintext highlighter-rouge">Environment secrets</code>, <code class="language-plaintext highlighter-rouge">Repository secrets</code>, <code class="language-plaintext highlighter-rouge">Organization secrets</code>라는 세가지 종류의 시크릿 환경변수를 보실 수 있습니다.</p>

<ul>
  <li><b>Environment secrets</b>
    <ul>
      <li>특정 환경에 대한 시크릿을 설정합니다.</li>
      <li>예) <code class="language-plaintext highlighter-rouge">development</code>, <code class="language-plaintext highlighter-rouge">staging</code>, <code class="language-plaintext highlighter-rouge">production</code> 등에 대한 시크릿.</li>
    </ul>
  </li>
  <li><b>Repository secrets</b>
    <ul>
      <li>특정 repository에 대한 시크릿을 설정합니다. 해당 repository에서 공통으로 사용되는 시크릿을 설정할 수 있습니다.</li>
      <li>예) <code class="language-plaintext highlighter-rouge">Docker ID/PW</code>, <code class="language-plaintext highlighter-rouge">AWS ID/PW</code>에 대한 시크릿.</li>
    </ul>
  </li>
  <li><b>Organization secrets</b>
    <ul>
      <li>조직에 대한 시크릿을 설정합니다. 조직 내의 모든 repository에서 공통으로 사용되는 시크릿을 설정할 수 있습니다.</li>
      <li>예) <code class="language-plaintext highlighter-rouge">AWS ID/PW</code>에 대한 시크릿.
<br />
<br /></li>
    </ul>
  </li>
</ul>

<p>본인의 상황에 맞게 시크릿을 설정하시면 되는데, 보통 <code class="language-plaintext highlighter-rouge">production</code>, <code class="language-plaintext highlighter-rouge">development</code>과 같이 환경을 나누어 관리하는 경우가 많기 때문에 <code class="language-plaintext highlighter-rouge">Environment secrets</code>를 사용하여 시크릿을 설정하는 것을 추천드립니다.
<br />
<br />
<code class="language-plaintext highlighter-rouge">development</code> 환경에서 사용할 시크릿을 설정해보겠습니다.<br />
<code class="language-plaintext highlighter-rouge">Manage environment secrets</code> 버튼을 클릭합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets-setting.png" alt="GitHub Secrets 설정" />
<br />
<br />
<br />
<code class="language-plaintext highlighter-rouge">New environment</code> 를 클릭하여 새 Environments를 생성합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets-new-environment.png" alt="GitHub Secrets New Environment" />
<br />
<br />
<br />
Environments에 대한 이름을 설정할 수 있는데, 저는 develop 브랜치의 CI/CD를 구현할 예정이므로 <code class="language-plaintext highlighter-rouge">development</code> 로 입력하겠습니다.<br />
입력 후 <code class="language-plaintext highlighter-rouge">Configure environment</code> 버튼을 클릭합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets-new-environment-name.png" alt="GitHub Secrets New Environment Name" />
<br />
<br />
<br />
Environments가 생성되면 아래와 같은 화면이 보이게 됩니다.<br />
여기서 배포 보호 규칙을 설정할 수도 있지만 이 부분은 스킵하겠습니다. <code class="language-plaintext highlighter-rouge">Deployment branches and tags</code>에서 <code class="language-plaintext highlighter-rouge">Select branches and tags</code>로 바꿔 배포할 브랜치를 설정해보겠습니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets-new-environment-setting.png" alt="GitHub Secrets New Environment Setting" />
<br />
<br />
<br />
그런 다음 Environments를 사용할 브랜치를 추가하면 됩니다.<br />
저는 <code class="language-plaintext highlighter-rouge">develop</code> 브랜치를 추가하겠습니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets-new-environment-setting2.png" alt="GitHub Secrets New Environment Setting2" />
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets-new-environment-setting3.png" alt="GitHub Secrets New Environment Setting3" />
<br />
<br />
<br />
이제 <code class="language-plaintext highlighter-rouge">development</code> 환경에 대한 설정이 완료되었으므로 시크릿 변수를 추가해봅시다.<br />
바로 아래 <code class="language-plaintext highlighter-rouge">Environment secrets</code> 탭에서 <code class="language-plaintext highlighter-rouge">New environment secret</code> 버튼을 클릭합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets-new-environment-secret.png" alt="GitHub Secrets New Environment Secret" />
<br />
<br />
<br />
이름과 값을 입력할 수 있는 화면이 보이는데 여기에 CI/CD에 필요한 시크릿 변수를 추가하면 됩니다.<br />
참고로 한번 설정된 시크릿 변수는 수정만 가능하고 볼 수 없으므로 주의하시기 바랍니다.<br />
저는 <code class="language-plaintext highlighter-rouge">DOCKER_USERNAME</code>, <code class="language-plaintext highlighter-rouge">DOCKER_PASSWORD</code>, <code class="language-plaintext highlighter-rouge">EC2_HOST</code>, <code class="language-plaintext highlighter-rouge">EC2_USER</code>, <code class="language-plaintext highlighter-rouge">SSH_PRIVATE_KEY</code>를 추가하겠습니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets-new-environment-secret-setting.png" alt="GitHub Secrets New Environment Secret Setting" />
<br />
<br />
<br />
<code class="language-plaintext highlighter-rouge">EC2_HOST</code>는 EC2의 <code class="language-plaintext highlighter-rouge">퍼블릭 IPv4 DNS</code>를, <code class="language-plaintext highlighter-rouge">EC2_USER</code>는 EC2에 접속하기 위한 사용자 이름을 입력하시면 됩니다.<br />
<code class="language-plaintext highlighter-rouge">SSH_PRIVATE_KEY</code>는 EC2에 접속하기 위한 개인키를 말하는데요. <code class="language-plaintext highlighter-rouge">.pem</code> 파일이나 <code class="language-plaintext highlighter-rouge">.ppk</code> 파일을 열어 개인키를 복사하여 붙여넣으면 됩니다.
<br />
<br />
macOS에서는 <code class="language-plaintext highlighter-rouge">cat</code> 명령어를 사용하여 개인키를 확인할 수 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># cat {파일위치}</span>
<span class="nv">$ </span><span class="nb">cat</span> ~/.ssh/your-key.pem
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/ec2-ssh-private-key.png" alt="ec2 ssh private key" />
<br />
📍 <b>ssh 키를 복사할 때는 반드시 Header와 Footer를 포함해서 복사해야 합니다!</b></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEAu06IpZklZ5W9L/AS56LAE95FvmmPhmO9MeyUItiw2jDfwaiR
...
-----END RSA PRIVATE KEY-----
</code></pre></div></div>

<h2 id="github-actions-workflow-생성하기">GitHub Actions Workflow 생성하기</h2>

<p>시크릿 변수를 모두 추가하셨다면 CI/CD를 실행할 파일을 생성해봅시다.<br />
GitHub Actions는 <code class="language-plaintext highlighter-rouge">.github/workflows</code> 폴더 내에 <code class="language-plaintext highlighter-rouge">yaml</code> 파일을 통해 CI/CD를 실행합니다.
<br />
<br />
프로젝트 repository 내에 <code class="language-plaintext highlighter-rouge">Actions</code> 탭에서 <code class="language-plaintext highlighter-rouge">New workflow</code> 버튼을 클릭하여 미리 정의된 템플릿을 사용할 수 있는데 대부분 템플릿을 사용하지 않고 직접 작성하시더라구요? 사실 템플릿을 사용할 만큼 파일을 작성하는게 어렵지 않아서 그런거 같습니다.<br />
그래서 저도 직접 작성해보려 합니다. 별로 어렵지 않으니… ㅎㅎ
<br />
<br />
일단 <code class="language-plaintext highlighter-rouge">.github/workflows</code> 폴더를 생성하고 그 안에 <code class="language-plaintext highlighter-rouge">.yml</code> 파일을 생성합니다.<br />
참고로 <code class="language-plaintext highlighter-rouge">.yml</code>, <code class="language-plaintext highlighter-rouge">.yaml</code> 둘다 같은 확장자이니 편하신걸로 사용하시면 됩니다. 만들어져 있는 production 환경 CI/CD 파일이 <code class="language-plaintext highlighter-rouge">.yml</code> 확장자라서 일관성을 위해 저도 <code class="language-plaintext highlighter-rouge">.yml</code>로 작성하겠습니다.<br />
파일 이름도 원하시는대로 작성하시면 되고, 저는 production 환경과 구분하기 위해 파일 이름은 <code class="language-plaintext highlighter-rouge">app-dev.yml</code>로 작성하겠습니다.
<br />
<br /></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># file: ".github/workflows/app-dev.yml"</span>
<span class="na">name</span><span class="pi">:</span> <span class="s">app-dev</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">develop</span><span class="pi">]</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">environment</span><span class="pi">:</span> <span class="s">development</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout repository</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set up Docker Buildx</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">docker/setup-buildx-action@v2</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Login to Docker Hub</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">docker/login-action@v2</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">username</span><span class="pi">:</span> <span class="s">${ { secrets.DOCKER_USERNAME } }</span>
          <span class="na">password</span><span class="pi">:</span> <span class="s">${ { secrets.DOCKER_PASSWORD } }</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build Docker image (development)</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">docker build --platform linux/amd64 -f Dockerfile.dev -t nicodora/honey-moa-dev:latest .</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Push Docker image</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">docker push nicodora/honey-moa-dev:latest</span>

      <span class="c1"># 배포 단계: EC2에 SSH로 접속하여 컨테이너 업데이트</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Deploy to EC2</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">appleboy/ssh-action@v0.1.8</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">host</span><span class="pi">:</span> <span class="s">${ { secrets.EC2_HOST } }</span>
          <span class="na">username</span><span class="pi">:</span> <span class="s">${ { secrets.EC2_USER } }</span>
          <span class="na">key</span><span class="pi">:</span> <span class="s">${ { secrets.SSH_PRIVATE_KEY } }</span>
          <span class="na">script</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s"># 기존 컨테이너 중지 및 삭제</span>
            <span class="s">sudo docker-compose -f docker-compose.dev.yaml down</span>

            <span class="s"># 오래된 이미지 정리</span>
            <span class="s">sudo docker rmi -f nicodora/honey-moa-dev:latest || true</span>

            <span class="s"># 최신 이미지 pull</span>
            <span class="s">sudo docker pull nicodora/honey-moa-dev:latest</span>

            <span class="s"># 최신 이미지로 Docker Compose 실행</span>
            <span class="s">sudo docker-compose -f docker-compose.dev.yaml up -d</span>
</code></pre></div></div>

<details>
<summary><b>코드 흐름</b></summary>
<div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">develop</code> 브랜치에 push가 발생하면 <code class="language-plaintext highlighter-rouge">app-dev.yml</code> 파일이 실행됩니다.</li>
      <li><code class="language-plaintext highlighter-rouge">ubuntu-latest</code> 환경에서 실행되며, <code class="language-plaintext highlighter-rouge">development</code> 환경을 사용합니다.</li>
      <li>도커에 로그인 하고 이미지를 빌드하여 <code class="language-plaintext highlighter-rouge">Docker Hub</code>에 푸시합니다.</li>
      <li><code class="language-plaintext highlighter-rouge">appleboy/ssh-action</code>을 사용하여 EC2에 SSH로 접속하여 컨테이너를 업데이트합니다.</li>
    </ul>
  </div>
</details>
<p><br />
<br />
이제 <code class="language-plaintext highlighter-rouge">app-dev.yml</code> 파일을 커밋하고 <code class="language-plaintext highlighter-rouge">develop</code> 브랜치에 푸시하면 CI/CD가 실행됩니다.</p>

<h2 id="github-actions-실행-확인하기">GitHub Actions 실행 확인하기</h2>

<p>Actions 탭에서 작성한 workflow 파일을 클릭해 보면 CI/CD가 실행되는 것을 확인할 수 있습니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-actions-run.png" alt="GitHub Actions 실행 확인" />
<br />
<br />
<br />
build 탭에 들어가보면 각 단계별로 자세한 로그를 확인할 수 있습니다.<br />
아래와 같이 ✅ 표시가 뜨면 성공적으로 실행된 것입니다!
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-actions-run2.png" alt="GitHub Actions 실행 확인2" />
<br />
<br />
<br />
이전에 수동으로 배포할 때는 약 5분정도 소요되었지만, GitHub Actions를 사용하여 CI/CD를 구축하니 평균 2분 10초 정도에 배포가 완료되는 모습입니다. 결과적으로 이전 수동 배포에 비해 56% 정도의 시간을 단축할 수 있었습니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-actions-run3.png" alt="GitHub Actions 실행 확인3" /></p>

<h2 id="마치며">마치며</h2>

<p>이번 포스팅에서는 GitHub Actions를 사용하여 CI/CD를 구축하는 방법에 대해 알아보았습니다.<br />
큰 노력 없이 CI/CD를 구축하여 배포 자동화를 할 수 있기에 지속적으로 코드를 배포한다고 하면 거의 필수 작업이라고 생각합니다.</p>

<p>그럼 다음 포스트에서 뵙겠습니다! 뾰로롱~
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/frieren1.gif" width="300" height="300" alt="프리렌 움짤1" /></p>]]></content><author><name>NicoDora</name></author><category term="github" /><summary type="html"><![CDATA[GitHub Actions를 사용하여 CI/CD를 구축하는 방법에 대해 알아보겠습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-actions.png" /><media:content medium="image" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-actions.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">AWS EC2에서 Nginx와 Certbot으로 Let’s encrypt SSL 인증서 발급하기</title><link href="http://localhost:4000/aws/AWS-EC2%EC%97%90%EC%84%9C-Nginx%EC%99%80-Certbot%EC%9C%BC%EB%A1%9C-Lets-encrypt-SSL-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="AWS EC2에서 Nginx와 Certbot으로 Let’s encrypt SSL 인증서 발급하기" /><published>2025-03-07T14:31:00+09:00</published><updated>2025-03-07T14:31:00+09:00</updated><id>http://localhost:4000/aws/AWS-EC2%EC%97%90%EC%84%9C-Nginx%EC%99%80-Certbot%EC%9C%BC%EB%A1%9C-Lets-encrypt-SSL-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/aws/AWS-EC2%EC%97%90%EC%84%9C-Nginx%EC%99%80-Certbot%EC%9C%BC%EB%A1%9C-Lets-encrypt-SSL-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/"><![CDATA[<ol id="markdown-toc">
  <li><a href="#들어가기-전에" id="markdown-toc-들어가기-전에">들어가기 전에</a></li>
  <li><a href="#사전-준비-환경" id="markdown-toc-사전-준비-환경">사전 준비 환경</a></li>
  <li><a href="#dns-체크" id="markdown-toc-dns-체크">DNS 체크</a></li>
  <li><a href="#docker-composeyaml-작성" id="markdown-toc-docker-composeyaml-작성">docker-compose.yaml 작성</a></li>
  <li><a href="#nginxconf-파일-작성" id="markdown-toc-nginxconf-파일-작성">nginx.conf 파일 작성</a></li>
  <li><a href="#nginx-임시-실행" id="markdown-toc-nginx-임시-실행">Nginx 임시 실행</a></li>
  <li><a href="#certbot으로-ssl-인증서-발급" id="markdown-toc-certbot으로-ssl-인증서-발급">Certbot으로 SSL 인증서 발급</a></li>
  <li><a href="#docker-composeyaml-파일-업데이트" id="markdown-toc-docker-composeyaml-파일-업데이트">docker-compose.yaml 파일 업데이트</a></li>
  <li><a href="#nginxconf-파일-업데이트" id="markdown-toc-nginxconf-파일-업데이트">nginx.conf 파일 업데이트</a></li>
  <li><a href="#docker-compose-실행" id="markdown-toc-docker-compose-실행">docker-compose 실행</a></li>
  <li><a href="#마치며" id="markdown-toc-마치며">마치며</a></li>
</ol>

<h2 id="들어가기-전에">들어가기 전에</h2>

<p>프로젝트를 진행중에 백엔드 개발서버를 배포해야 할 상황이 와서 급하게 EC2와 RDS를 만들고 SSL 인증서를 발급받으려고 할 때 갑자기 이런 생각이 들었습니다. <b>“이거 블로그에 정리해두면 좋겠다!”</b> 라고…
<br />
<br />
백엔드 서버의 배포과정을 A to Z로 정리하면 좋겠지만…<br />
이미 AWS 세팅은 대부분 완료된 상태라서, SSL 인증서 발급과정만 정리해보려고 합니다.
<br />
<br />
사실 SSL 인증서 발급 부분도 처음 적용하는 사람 입장에서는 헷갈릴 수 있는 부분이 많아서, 블로그에 정리해두면 분명 다른 사람들에게 도움이 될 거라고 생각합니다! (실제로 저도 처음에는 많이 헤맸거든요… ㅎㅎ;;)</p>

<h2 id="사전-준비-환경">사전 준비 환경</h2>

<p>일단 저의 환경은 아래와 같습니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/dev-server-architecture1.png" alt="dev 서버 아키텍쳐1" /></p>

<ul>
  <li>AWS EC2 인스턴스 (Ubuntu)</li>
  <li>도메인 구매 및 연결 (가비아, AWS Route53)</li>
  <li>EC2에서 Docker로 백엔드 서버 실행
<br />
<br />
<br />
해당 환경을 다음과 같이 수정해보려 합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/dev-server-architecture2.png" alt="dev 서버 아키텍쳐2" /></li>
</ul>

<p><br />
여기서 도메인 구매는 필수가 아니기 때문에 EC2 인스턴스에 할당된 퍼블릭 IPv4 주소를 사용해도 괜찮지만, 저는 도메인을 구매했기 때문에 도메인을 사용해서 진행하겠습니다.
<br />
<br />
Docker를 사용하지 않고 EC2 인스턴스에 Nginx를 설치하고 SSL 인증서를 발급받는 방법도 있지만, Docker를 사용하면 더 간편하게 관리할 수 있기 때문에 저는 Docker 사용을 추천드립니다.
<br />
<br />
EC2 인스턴스에 Docker 및 docker-compose 설치는 아래 명령어를 차례대로 입력하시면 됩니다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1-1. 프로그램 설치 전 우분투 시스템 패키지 업데이트</span>
<span class="nv">$ </span><span class="nb">sudo </span>apt-get update

<span class="c"># 1-2. 필요한 패키지 설치</span>
<span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>apt-transport-https ca-certificates curl gnupg-agent software-properties-common

<span class="c"># 1-3. Docker의 공식 GPG 키 추가</span>
<span class="nv">$ </span>curl <span class="nt">-fsSL</span> https://download.docker.com/linux/ubuntu/gpg | <span class="nb">sudo </span>apt-key add -

<span class="c"># 1-4. Docker의 공식 apt 저장소 추가</span>
<span class="nv">$ </span><span class="nb">sudo </span>add-apt-repository <span class="s2">"deb [arch=amd64] https://download.docker.com/linux/ubuntu </span><span class="si">$(</span>lsb_release <span class="nt">-cs</span><span class="si">)</span><span class="s2"> stable"</span>

<span class="c"># 1-5. 시스템 패키지 업데이트</span>
<span class="nv">$ </span><span class="nb">sudo </span>apt-get update

<span class="c"># 1-6. Docker 설치</span>
<span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>docker-ce docker-ce-cli containerd.io

<span class="c"># 2-1. Docker Compose 설치</span>
<span class="nv">$ </span><span class="nb">sudo </span>curl <span class="nt">-L</span> <span class="s2">"https://github.com/docker/compose/releases/download/1.27.4/docker-compose-</span><span class="si">$(</span><span class="nb">uname</span> <span class="nt">-s</span><span class="si">)</span><span class="s2">-</span><span class="si">$(</span><span class="nb">uname</span> <span class="nt">-m</span><span class="si">)</span><span class="s2">"</span> <span class="nt">-o</span> /usr/local/bin/docker-compose

<span class="c"># 2-2. 다운로드 한 파일에 권한 설정</span>
<span class="nv">$ </span><span class="nb">sudo chmod</span> +x /usr/local/bin/docker-compose

<span class="c"># 2-3. Docker Compose 버전 확인 (정상적으로 설치되었는지 확인)</span>
<span class="nv">$ </span>docker-compose <span class="nt">--version</span>
</code></pre></div></div>

<p><a href="https://velog.io/@jjeongdong/Devops-Docker-Compose%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-EC2%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%B0%B0%ED%8F%AC#ec2-linux%EC%97%90-docker--docker-compose-%EC%84%A4%EC%B9%98">출처</a></p>

<h2 id="dns-체크">DNS 체크</h2>

<p>도메인을 구매하신 분들이라면 DNS가 정상적으로 설정되었는지 확인해보셔야 합니다.<br />
터미널에서 아래 명령어를 입력하시면 됩니다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dig {도메인}</span>
<span class="nv">$ </span>dig dev.honeymoa.kr
</code></pre></div></div>

<p>정상적으로 설정되었다면 아래와 같이 <code class="language-plaintext highlighter-rouge">status</code>가 <code class="language-plaintext highlighter-rouge">NOERROR</code>로 나오고, <code class="language-plaintext highlighter-rouge">ANSWER SECTION</code>에 도메인과 연결된 IP 주소가 나옵니다.
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/dns-check.png" alt="DNS 설정 확인" />
<br />
<br />
혹시나 <code class="language-plaintext highlighter-rouge">status</code>가 <code class="language-plaintext highlighter-rouge">NXDOMAIN</code>으로 나오신다면 도메인 설정이 잘못되었거나, DNS 서버에 도메인 정보가 전파되지 않은 것입니다.<br />
다시한번 도메인 설정을 확인하시고, 올바르게 설정하셨다면 DNS 서버에 도메인 정보가 전파될 때까지 기다려주세요.</p>

<h2 id="docker-composeyaml-작성">docker-compose.yaml 작성</h2>

<p><span style="color:#808080"> 📍 <em>지금부터 파일 작성은 EC2 인스턴스에 접속했을 때의 <b>루트 디렉토리(/home/ubuntu)</b>에서 진행되니 유의해주세요!</em> </span></p>

<p>레거시한 방법으로 SSL 인증서를 발급하려면 EC2 인스턴스에 Nginx를 설치하고, Certbot을 설치해야 하지만,<br />
Docker를 사용하면 Nginx와 Certbot을 컨테이너로 한번에 실행할 수 있습니다.
<br />
<br />
아래와 같이 <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> 파일을 작성해줍니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># file: "docker-compose.yaml"</span>
<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.7'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">nginx</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:1.15-alpine</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">80:80'</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./nginx/nginx.conf:/etc/nginx/nginx.conf</span>
      <span class="pi">-</span> <span class="s">./nginx/www/certbot:/var/www/certbot</span>
      <span class="pi">-</span> <span class="s">./nginx/logs:/var/log/nginx</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">unless-stopped</span>

  <span class="na">certbot</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">certbot/certbot</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">certbot</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./nginx/www/certbot:/var/www/certbot</span>
      <span class="pi">-</span> <span class="s">./nginx/ssl:/etc/letsencrypt</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">certonly --webroot --webroot-path=/var/www/certbot -d {도메인}</span>
</code></pre></div></div>
<p><br />
간단하게 위 코드에 대해서 설명드리겠습니다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">nginx</code> 서비스
    <ul>
      <li><code class="language-plaintext highlighter-rouge">image</code>: 사용할 Nginx 이미지</li>
      <li><code class="language-plaintext highlighter-rouge">container_name</code>: 컨테이너 이름</li>
      <li><code class="language-plaintext highlighter-rouge">ports</code>: 호스트와 컨테이너의 포트 매핑 (80:80)</li>
      <li><code class="language-plaintext highlighter-rouge">volumes</code>: 호스트와 컨테이너의 디렉토리 매핑</li>
      <li><code class="language-plaintext highlighter-rouge">restart</code>: 컨테이너가 중지되었을 때 재시작할 정책 설정</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">certbot</code> 서비스
    <ul>
      <li><code class="language-plaintext highlighter-rouge">image</code>: 사용할 Certbot 이미지</li>
      <li><code class="language-plaintext highlighter-rouge">container_name</code>: 컨테이너 이름</li>
      <li><code class="language-plaintext highlighter-rouge">volumes</code>: 호스트와 컨테이너의 디렉토리 매핑</li>
      <li><code class="language-plaintext highlighter-rouge">command</code>: Certbot 명령어 (인증서 발급)
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h2 id="nginxconf-파일-작성">nginx.conf 파일 작성</h2>

<p><code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> 파일에서 볼륨 마운트 설정을 보면 <code class="language-plaintext highlighter-rouge">nginx/</code> 디렉토리가 필요한 것을 확인할 수 있습니다.
<br /></p>

<p class="note">전체적인 디렉토리 구조는 아래와 같습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/home/ubuntu
├── docker-compose.yaml
├── nginx
│   ├── nginx.conf
│   ├── ssl/
│   │   ├── (certbot 인증서)
│   ├── logs/
│   └── www/
│       └── certbot/
└── .env
</code></pre></div></div>
<p><br /></p>

<p>아래와 같이 <b><code class="language-plaintext highlighter-rouge">nginx</code></b> 디렉토리를 생성해줍니다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir </span>nginx
</code></pre></div></div>

<p><br />
그리고 <code class="language-plaintext highlighter-rouge">nginx</code> 디렉토리 안에 <b><code class="language-plaintext highlighter-rouge">nginx.conf</code></b> 파일을 생성해줍니다.<br />
<code class="language-plaintext highlighter-rouge">nginx.conf</code> 파일은 Nginx가 실행될 때 사용하는 설정 파일로, 아래와 같이 작성해줍니다.</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># file: "nginx/nginx.conf"</span>
<span class="k">events</span> <span class="p">{</span>
  <span class="kn">worker_connections</span> <span class="mi">1024</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">http</span> <span class="p">{</span>
  <span class="kn">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">dev.honeymoa.kr</span><span class="p">;</span> <span class="c1"># server_name {도메인}</span>

    <span class="kn">location</span> <span class="n">/.well-known/acme-challenge/</span> <span class="p">{</span>
      <span class="kn">root</span> <span class="n">/var/www/certbot</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
      <span class="kn">return</span> <span class="mi">404</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<details>
<summary><b>nginx.conf 파일 설명</b></summary>
<div>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">events</code> 블록에서는 Nginx 작업자가 동시에 처리할 수 있는 최대 연결 수를 설정합니다. 여기서 <code class="language-plaintext highlighter-rouge">worker_connections 1024;</code>는 각각의 작업자가 최대 1024개의 연결을 동시에 처리할 수 있도록 지정합니다.</p>
      </li>
      <li>
        <p>다음으로, <code class="language-plaintext highlighter-rouge">http</code> 블록 내부에 정의된 <code class="language-plaintext highlighter-rouge">server</code> 블록은 80번 포트를 리스닝하며, 도메인에 대한 요청을 처리합니다.</p>
        <ul>
          <li>첫 번째 <code class="language-plaintext highlighter-rouge">location</code> 블록은 <code class="language-plaintext highlighter-rouge">/.well-known/acme-challenge/</code>경로에 대한 요청을 처리합니다. 여기서는 해당 경로의 요청에 대해 <code class="language-plaintext highlighter-rouge">/var/www/certbot</code> 디렉토리에서 파일을 제공하도록 설정되어 있습니다.</li>
          <li>두 번째 location 블록은 <code class="language-plaintext highlighter-rouge">/</code>로 시작하는 모든 다른 요청에 대해 404 응답을 반환합니다. 인증서 발급 관련 요청 외의 다른 접근을 차단하기 위한 설정입니다.</li>
        </ul>
      </li>
    </ul>
  </div>
</details>
<p><br /></p>

<p>나머지 <code class="language-plaintext highlighter-rouge">/nginx/www/</code>, <code class="language-plaintext highlighter-rouge">/nginx/logs/</code>, <code class="language-plaintext highlighter-rouge">/nginx/ssl/</code> 디렉토리는 Nginx 실행 시 자동으로 생성되기 때문에 수동으로 생성할 필요는 없습니다.</p>

<h2 id="nginx-임시-실행">Nginx 임시 실행</h2>

<p><code class="language-plaintext highlighter-rouge">nginx.conf</code> 파일 작성이 완료되었으므로 이제 Nginx를 실행해보겠습니다.
<br />
<br /></p>

<p><code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> 파일이 있는 디렉토리에서 아래 명령어를 입력하여 Nginx를 실행합니다.<br />
<span style="color:#808080"><em>(만약 <code class="language-plaintext highlighter-rouge">docker-compose</code> 파일의 이름이 다르다면 <code class="language-plaintext highlighter-rouge">-f</code> 옵션을 사용하여 파일 이름을 지정해주셔야 합니다.)</em></span></p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose up <span class="nt">-d</span> nginx
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/nginx-up.png" alt="nginx 실행" /></p>

<p><br />
컨테이너가 정상적으로 실행되었는지 확인합니다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 로그가 없어야 정상적으로 실행된 것입니다.</span>
<span class="nv">$ </span>docker logs nginx

<span class="c"># nginx.conf 파일 문법 검사</span>
<span class="nv">$ </span>docker-compose <span class="nb">exec </span>nginx nginx <span class="nt">-t</span>

<span class="c"># nginx가 실행중인지 확인</span>
<span class="nv">$ </span>docker ps
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/nginx-check.png" alt="nginx 실행 확인" />
<br /></p>

<h2 id="certbot으로-ssl-인증서-발급">Certbot으로 SSL 인증서 발급</h2>

<p>이제 Nginx가 실행되었으니 Certbot을 사용하여 SSL 인증서를 발급받아보겠습니다.<br />
1️⃣ <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> 파일이 있는 디렉토리에서 아래 명령어를 입력하여 Certbot 컨테이너를 실행합니다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose run <span class="nt">--rm</span> certbot
</code></pre></div></div>
<p><br />
2️⃣ 긴급 갱신 및 보안 알림에 사용할 이메일 주소를 입력하라고 나오니 적절한 이메일 주소를 입력해줍니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Saving debug log to /var/log/letsencrypt/letsencrypt.log
Enter email address (used for urgent renewal and security notices)
 (Enter 'c' to cancel):
</code></pre></div></div>
<p><br />
3️⃣ 약관에 동의하라는 메시지가 나오는데, 약관에 동의해야 인증서 발급이 되니 <code class="language-plaintext highlighter-rouge">Y</code>를 입력해줍니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Please read the Terms of Service at:
https://letsencrypt.org/documents/LE-SA-v1.5-February-24-2025.pdf
You must agree in order to register with the ACME server. Do you agree?
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
(Y)es/(N)o: Y
</code></pre></div></div>
<p><br />
4️⃣ 홍보성 메일 수신 여부를 묻는 메시지가 나오는데, 원하시는 대로 선택하시면 됩니다.<br />
저는 메일 수신을 원하지 않아서 <code class="language-plaintext highlighter-rouge">N</code>을 입력했습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Would you be willing, once your first certificate is successfully issued, to
share your email address with the Electronic Frontier Foundation, a founding
partner of the Let's Encrypt project and the non-profit organization that
develops Certbot? We'd like to send you email about our work encrypting the web,
EFF news, campaigns, and ways to support digital freedom.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
(Y)es/(N)o: N
</code></pre></div></div>
<p><br />
📍 <span style="color:#F08080">아래와 같은 에러가 발생한다면 AWS 보안 그룹에서 <code class="language-plaintext highlighter-rouge">80</code>번 포트가 열려있는지 확인해주세요!</span></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Account registered.
Requesting a certificate for dev.honeymoa.kr

Certbot failed to authenticate some domains (authenticator: webroot). The Certificate Authority reported these problems:
  Domain: dev.honeymoa.kr
  Type:   connection
  Detail: 3.39.69.185: Fetching http://dev.honeymoa.kr/.well-known/acme-challenge/SLl0wrWe_5cmAZN6XAX0zq8kboOBEETuiT5WcMvSrtM: Timeout during connect (likely firewall problem)

Hint: The Certificate Authority failed to download the temporary challenge files created by Certbot. Ensure that the listed domains serve their content from the provided --webroot-path/-w and that files created there can be downloaded from the internet.

Some challenges have failed.
Ask for help or search for solutions at https://community.letsencrypt.org. See the logfile /var/log/letsencrypt/letsencrypt.log or re-run Certbot with -v for more details.
</code></pre></div></div>
<p><br />
5️⃣ <span style="color:#32CD32">인증서 발급이 완료되면 아래와 같은 메시지가 출력됩니다.</span></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Requesting a certificate for dev.honeymoa.kr

Successfully received certificate.
Certificate is saved at: /etc/letsencrypt/live/dev.honeymoa.kr/fullchain.pem
Key is saved at:         /etc/letsencrypt/live/dev.honeymoa.kr/privkey.pem
This certificate expires on 2025-06-04.
These files will be updated when the certificate renews.

NEXT STEPS:
- The certificate will need to be renewed before it expires. Certbot can automatically renew the certificate in the background, but you may need to take steps to enable that functionality. See https://certbot.org/renewal-setup for instructions.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
If you like Certbot, please consider supporting our work by:
 * Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate
 * Donating to EFF:                    https://eff.org/donate-le
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
</code></pre></div></div>
<p><br />
인증서 발급에 성공하면 <b><code class="language-plaintext highlighter-rouge">/nginx/ssl/live/{도메인}/</code></b> 디렉토리 안에 인증서와 개인키가 저장됩니다.<br />
인증서와 개인키는 각각 <b><code class="language-plaintext highlighter-rouge">fullchain.pem</code></b>과 <b><code class="language-plaintext highlighter-rouge">privkey.pem</code></b> 파일에 저장됩니다.
<br />
<br />
인증서와 개인키가 정상적으로 발급되었는지 확인하고 싶다면 아래 명령어를 입력하시면 됩니다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 인증서 확인</span>
<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-al</span> /nginx/ssl/live/<span class="o">{</span>도메인<span class="o">}</span>
</code></pre></div></div>
<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/cert-check.png" alt="인증서 확인" />
<br /></p>

<h2 id="docker-composeyaml-파일-업데이트">docker-compose.yaml 파일 업데이트</h2>

<p>인증서 발급이 완료되었으니 아래 명령어를 입력하여 Nginx를 종료합니다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose down
</code></pre></div></div>
<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/nginx-down.png" alt="nginx 종료" />
<br />
<br />
이제 <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> 파일을 완성해봅시다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># file: "docker-compose.yaml"</span>
<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.8'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">honey-moa-dev</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nicodora/honey-moa-dev:latest</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">honey-moa-dev</span>
    <span class="na">env_file</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">.env</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">3000:3000'</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">honey-moa-dev-network</span>

  <span class="na">nginx</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:1.15-alpine</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">80:80'</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">443:443'</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./nginx/nginx.conf:/etc/nginx/nginx.conf</span> <span class="c1"># nginx.conf 파일</span>
      <span class="pi">-</span> <span class="s">./nginx/www/certbot:/var/www/certbot</span> <span class="c1"># certbot이 사용할 디렉토리</span>
      <span class="pi">-</span> <span class="s">./nginx/ssl:/etc/letsencrypt</span> <span class="c1"># ssl 인증서 저장 디렉토리</span>
      <span class="pi">-</span> <span class="s">./nginx/logs:/var/log/nginx</span> <span class="c1"># nginx 로그 저장 디렉토리</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">honey-moa-dev</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">unless-stopped</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">honey-moa-dev-network</span>

  <span class="na">certbot</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">certbot/certbot</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">certbot</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./nginx/www/certbot:/var/www/certbot</span> <span class="c1"># certbot이 사용할 디렉토리</span>
      <span class="pi">-</span> <span class="s">./nginx/ssl:/etc/letsencrypt</span> <span class="c1"># ssl 인증서 저장 디렉토리</span>
    <span class="na">entrypoint</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/bin/sh</span><span class="nv"> </span><span class="s">-c</span><span class="nv"> </span><span class="s">'trap</span><span class="nv"> </span><span class="s">exit</span><span class="nv"> </span><span class="s">TERM;</span><span class="nv"> </span><span class="s">while</span><span class="nv"> </span><span class="s">:;</span><span class="nv"> </span><span class="s">do</span><span class="nv"> </span><span class="s">certbot</span><span class="nv"> </span><span class="s">renew;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">12h</span><span class="nv"> </span><span class="s">&amp;</span><span class="nv"> </span><span class="s">wait</span><span class="nv"> </span><span class="s">$${!};</span><span class="nv"> </span><span class="s">done;'"</span> <span class="c1"># 인증서 자동 갱신</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">unless-stopped</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">honey-moa-dev-network</span>

<span class="na">networks</span><span class="pi">:</span>
  <span class="na">honey-moa-dev-network</span><span class="pi">:</span> <span class="c1"># 네트워크 설정</span>
    <span class="na">driver</span><span class="pi">:</span> <span class="s">bridge</span>
</code></pre></div></div>

<details>
<summary><b>docker-compose.yaml 파일 설명</b></summary>
<div>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> 파일에서 <code class="language-plaintext highlighter-rouge">honey-moa-dev</code>(백엔드 서버), <code class="language-plaintext highlighter-rouge">nginx</code>, <code class="language-plaintext highlighter-rouge">certbot</code> 을 정의합니다.</li>
      <li>nginx 서비스는 80번과 443번 포트를 리스닝하고, 볼륨 마운트를 통해 nginx.conf 파일과 인증서, 로그 디렉토리를 연결합니다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">depends_on:</code> 옵션을 사용하여 Nginx가 백엔드 서버에 의존하도록 설정하여 백엔드 서버가 실행된 후에 시작됩니다.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">certbot</code> 서비스는 <code class="language-plaintext highlighter-rouge">entrypoint</code>를 사용하여 Certbot이 12시간마다 인증서를 갱신하도록 설정했습니다.</li>
      <li><code class="language-plaintext highlighter-rouge">networks:</code> 옵션을 사용하여 <code class="language-plaintext highlighter-rouge">honey-moa-dev-network</code>라는 네트워크를 생성하고, 모든 서비스가 이 네트워크를 사용하도록 설정했습니다.</li>
    </ul>
  </div>
</details>

<h2 id="nginxconf-파일-업데이트">nginx.conf 파일 업데이트</h2>

<p>인증서 발급이 완료되었으므로 요청을 <code class="language-plaintext highlighter-rouge">HTTPS</code>로 받을 수 있도록 <code class="language-plaintext highlighter-rouge">nginx.conf</code> 파일도 업데이트 해줍니다.</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># file: "nginx/nginx.conf"</span>
<span class="k">events</span> <span class="p">{</span>
  <span class="kn">worker_connections</span> <span class="mi">1024</span><span class="p">;</span> <span class="c1"># 워커 프로세스가 처리할 수 있는 최대 연결 수</span>
<span class="p">}</span>

<span class="k">http</span> <span class="p">{</span>
  <span class="kn">upstream</span> <span class="s">backend</span> <span class="p">{</span>
      <span class="kn">server</span> <span class="nf">honey-moa-dev</span><span class="p">:</span><span class="mi">3000</span><span class="p">;</span> <span class="c1"># 백엔드 컨테이너 연결</span>
  <span class="p">}</span>

  <span class="c1"># HTTPS 설정</span>
  <span class="kn">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">dev.honeymoa.kr</span><span class="p">;</span> <span class="c1"># server_name {도메인}</span>

    <span class="kn">ssl_certificate</span> <span class="n">/etc/letsencrypt/live/dev.honeymoa.kr/fullchain.pem</span><span class="p">;</span> <span class="c1"># SSL 인증서 경로</span>
    <span class="kn">ssl_certificate_key</span> <span class="n">/etc/letsencrypt/live/dev.honeymoa.kr/privkey.pem</span><span class="p">;</span> <span class="c1"># SSL 개인키 경로</span>

    <span class="kn">ssl_protocols</span> <span class="s">TLSv1.2</span> <span class="s">TLSv1.3</span><span class="p">;</span>
    <span class="kn">ssl_ciphers</span> <span class="s">HIGH:!aNULL:!MD5</span><span class="p">;</span>

    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
      <span class="kn">proxy_pass</span> <span class="s">http://backend</span><span class="p">;</span>
      <span class="kn">proxy_http_version</span> <span class="mf">1.1</span><span class="p">;</span>
      <span class="kn">proxy_set_header</span> <span class="s">Upgrade</span> <span class="nv">$http_upgrade</span><span class="p">;</span>
      <span class="kn">proxy_set_header</span> <span class="s">Connection</span> <span class="s">'upgrade'</span><span class="p">;</span>
      <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="nv">$host</span><span class="p">;</span>
      <span class="kn">proxy_cache_bypass</span> <span class="nv">$http_upgrade</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1"># HTTP -&gt; HTTPS 리디렉션 설정</span>
  <span class="kn">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">dev.honeymoa.kr</span><span class="p">;</span> <span class="c1"># server_name {도메인}</span>

    <span class="kn">location</span> <span class="n">/.well-known/acme-challenge/</span> <span class="p">{</span>
      <span class="kn">root</span> <span class="n">/var/www/certbot</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kn">return</span> <span class="mi">301</span> <span class="s">https://</span><span class="nv">$host$request_uri</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<details>
<summary><b>nginx.conf 파일 설명</b></summary>
<div>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">upstream backend</code> 블록은 백엔드 서버의 주소를 설정합니다.
        <ul>
          <li>여기서는 <code class="language-plaintext highlighter-rouge">honey-moa-dev:3000</code>으로 설정하여 <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code>에서 정의했던 서비스 이름을 사용합니다.</li>
        </ul>
      </li>
      <li>첫번째 <code class="language-plaintext highlighter-rouge">server</code> 블록은 HTTPS 요청을 처리합니다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">listen 443 ssl;</code>은 443번 포트를 SSL로 리스닝하도록 설정합니다.</li>
          <li><code class="language-plaintext highlighter-rouge">ssl_certificate</code>와 <code class="language-plaintext highlighter-rouge">ssl_certificate_key</code>는 발급받은 SSL 인증서와 개인키의 경로를 설정합니다.</li>
          <li><code class="language-plaintext highlighter-rouge">ssl_protocols</code>와 <code class="language-plaintext highlighter-rouge">ssl_ciphers</code>는 SSL 프로토콜과 암호화 방식을 설정합니다.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">location /</code> 블록은 모든 요청을 백엔드 서버로 프록시 패스합니다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">proxy_pass</code>는 요청을 백엔드 서버로 전달합니다.</li>
          <li><code class="language-plaintext highlighter-rouge">proxy_set_header</code>는 요청 헤더를 설정하여 클라이언트의 정보를 백엔드 서버에 전달합니다.</li>
        </ul>
      </li>
      <li>두번째 <code class="language-plaintext highlighter-rouge">server</code> 블록은 HTTP 요청을 HTTPS로 리디렉션합니다.</li>
    </ul>
  </div>
</details>

<h2 id="docker-compose-실행">docker-compose 실행</h2>
<p>이제 모든 설정이 완료되었으니 아래 명령어를 입력하여 컨테이너를 실행해봅시다!</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose up <span class="nt">-d</span>
</code></pre></div></div>
<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/docker-compose-up.png" alt="docker-compose 실행" />
<br /></p>

<p><code class="language-plaintext highlighter-rouge">Nginx</code> 컨테이너가 정상적으로 실행되었는지 확인:</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># nginx.conf 파일 문법 검사</span>
<span class="nv">$ </span>docker-compose <span class="nb">exec </span>nginx nginx <span class="nt">-t</span>

<span class="c"># HTTPS 요청 확인</span>
<span class="c"># curl -I https://{도메인}</span>
<span class="nv">$ </span>curl <span class="nt">-I</span> https://dev.honeymoa.kr
</code></pre></div></div>
<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/docker-compose-nginx-check.png" alt="docker-compose nginx 실행 확인" />
<br /></p>

<p><code class="language-plaintext highlighter-rouge">Certbot</code> 컨테이너가 정상적으로 실행되었는지 확인:</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># certbot 컨테이너 실행 확인</span>
<span class="nv">$ </span>docker logs certbot
</code></pre></div></div>
<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/docker-compose-certbot-check.png" alt="docker-compose certbot 실행 확인" />
<br /></p>

<p>각 컨테이너들의 실행 확인까지 마치셨다면 SSL 인증서 적용 후, Certbot을 이용한 자동 갱신까지 완성입니다! 🎉</p>

<h2 id="마치며">마치며</h2>

<p>오늘은 AWS EC2 인스턴스에서 Nginx와 Certbot을 사용하여 SSL 인증서를 발급받고 자동갱신까지 설정하는 방법을 알아보았습니다.
처음 SSL 인증서를 발급받는 과정을 접한다면 생소하고, 특히 <code class="language-plaintext highlighter-rouge">nginx.conf</code> 파일과 <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> 파일을 작성하는 부분에서 어려움을 느끼실 수 있는데요. 조급해 하지 말고 차근차근 각 단계에 대해 알아보고 여러번 적용해보면 금방 익숙해질 수 있을겁니다.</p>

<p>그럼 다음 포스트에서 뵙겠습니다! 뾰로롱~
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/frieren1.gif" width="300" height="300" alt="프리렌 움짤1" /></p>]]></content><author><name>NicoDora</name></author><category term="aws" /><summary type="html"><![CDATA[AWS EC2 인스턴스에서 Nginx를 사용하여 Let's encrypt SSL 인증서를 발급받고 Certbot으로 인증서 자동갱신까지 설정하는 방법을 다룹니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/letsencrypt-logo.png" /><media:content medium="image" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/letsencrypt-logo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Docker 설치하기 for macOS</title><link href="http://localhost:4000/docker/Docker-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0-for-macOS/" rel="alternate" type="text/html" title="Docker 설치하기 for macOS" /><published>2024-04-03T15:50:00+09:00</published><updated>2024-04-03T15:50:00+09:00</updated><id>http://localhost:4000/docker/Docker-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0-for-macOS</id><content type="html" xml:base="http://localhost:4000/docker/Docker-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0-for-macOS/"><![CDATA[<ol id="markdown-toc">
  <li><a href="#docker란" id="markdown-toc-docker란">Docker란?</a></li>
  <li><a href="#macos에-docker-설치하기" id="markdown-toc-macos에-docker-설치하기">macOS에 Docker 설치하기</a></li>
  <li><a href="#마치며" id="markdown-toc-마치며">마치며</a></li>
</ol>

<h2 id="docker란">Docker란?</h2>

<p>도커(Docker)는 리눅스 컨테이너를 사용하여 애플리케이션을 더 쉽게 만들고 배포할 수 있도록 해주는 플랫폼입니다. 도커는 컨테이너 이미지를 사용하여 애플리케이션을 빌드하고 배포할 수 있습니다.
<br />
<br />
여기서 <b>컨테이너</b>는 격리된 환경에서 애플리케이션을 실행할 수 있도록 하는 기술입니다.<br />
컨테이너는 필요한 모든 라이브러리, 종속성 및 설정을 포함하는 격리된 패키지로서, 개발자는 개발 환경과 운영 환경 간의 일관성을 유지할 수 있습니다. 또한, 컨테이너는 빠르게 시작되고 쉽게 이동할 수 있어서 애플리케이션을 더 쉽게 배포하고 확장할 수 있습니다.
<br />
<br />
컨테이너 기술의 주요 장점은 다음과 같습니다.</p>
<ol>
  <li>
    <p><b>경량화</b><br />
   가상화된 운영 체제를 사용하는 가상 머신에 비해 더 적은 자원을 사용합니다.</p>
  </li>
  <li>
    <p><b>이식성</b><br />
   컨테이너는 호스트 시스템과 상관없이 동일한 방식으로 동작하므로 이식성이 뛰어납니다.</p>
  </li>
  <li>
    <p><b>일관성</b><br />
   컨테이너는 필요한 라이브러리 및 종속성을 포함하므로 환경이 일관되며, 개발 및 배포 과정이 표준화됩니다.</p>
  </li>
  <li>
    <p><b>확장성</b><br />
   컨테이너는 쉽게 배포되고 확장될 수 있어서 애플리케이션의 요구 사항에 따라 빠르게 조정할 수 있습니다.</p>
  </li>
</ol>

<p><br />
<br />
도커 로고를 보시면 고래가 그려져 있고 그 위에 컨테이너가 올려져 있는 모습을 볼 수 있습니다.<br />
<b>“바다 위에 배가 떠다니면서 그 위에 컨테이너를 올려 놓고 필요할 때마다 컨테이너에 접근하여 사용한다.”</b>라고 생각하시면 좋을 것 같습니다! 😊
<br />
<br />
<br />
<b>이미지</b>는 우리가 흔히 알고 있는 사진이나 그림 파일을 의미하는 것이 아니라, 컨테이너 실행에 필요한 파일과 설정 등을 포함하는 템플릿 입니다.
<br />
<br />
이미지는 값이 변하지 않는 정적인 파일이며, 컨테이너는 이미지를 실행한 상태입니다.<br />
때문에 컨테이너를 삭제하더라도 이미지는 영향을 받지 않고 그대로 남아있습니다.</p>

<p>또, 이미지에는 컨테이너를 실행하기 위해 필요한 모든 파일을 가지고 있기 때문에 복잡하게 이것저것 설정해주지 않아도 간편하게 컨테이너를 실행할 수 있으며, 하나의 이미지로 여러 개의 컨테이너를 실행할 수도 있습니다.</p>

<h2 id="macos에-docker-설치하기">macOS에 Docker 설치하기</h2>

<p>도커에 대한 설명은 간략하게 이 정도로 마치고, 이제 macOS에 도커를 설치해봅시다!</p>

<p><a href="https://www.docker.com/products/docker-desktop/">Docker 다운로드</a> 페이지에 접속하여 본인의 컴퓨터 환경에 맞춰 도커를 다운로드 받습니다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-download-page.png" alt="Docker 다운로드 페이지" />
<br />
<br />
<br />
다운로드가 완료되었다면 다운로드 받은 <code class="language-plaintext highlighter-rouge">Docker.dmg</code>파일을 실행하여 설치를 진행합니다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-install.png" alt="Docker 설치 화면" />
<br />
<br />
<br />
설치가 완료되면 ‘응용프로그램’에서 도커 앱이 추가된 것을 확인할 수 있습니다.</p>

<p>도커 앱을 실행해봅시다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-start.png" alt="Docker 앱 실행" />
<br />
<code class="language-plaintext highlighter-rouge">Accept</code>를 눌러 도커 약관에 동의하고 넘어갑니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-setting.png" alt="Docker 초기 설정" />
<br />
초기 설정은 기본값(추천)으로 설정하고 <code class="language-plaintext highlighter-rouge">Finish</code>를 눌러 다음 단계로 넘어갑니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-signin.png" alt="Docker 로그인" /></p>

<p>도커 허브 계정이 있다면 로그인을 하고, 없다면 스킵하셔도 됩니다.<br />
어짜피 도커는 계속 사용할테니 저는 계정을 새로 만들어서 로그인했습니다.
<br />
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-main.png" alt="Docker 메인화면" />
<br />
이제 도커 설치가 완료되었습니다!
<br />
<br />
<br />
터미널을 열어 아래 명령어를 입력하여 도커가 정상적으로 설치되었는지 확인해봅시다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nt">--version</span>
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-version-check.png" alt="Docker 버전 확인" />
<br />
도커 버전이 출력된다면 정상적으로 설치완료 된 것입니다! 👍</p>

<h2 id="마치며">마치며</h2>

<p>오늘은 도커에 대해 알아보고 macOS에 도커를 설치해봤습니다.<br />
다음 포스트에서는 도커 이미지를 다운받은 후 컨테이너를 실행하고 관리하는 방법에 대해 알아보겠습니다.</p>

<p>그럼 다음 포스트에서 뵙겠습니다! 뾰로롱~
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/frieren1.gif" width="300" height="300" alt="프리렌 움짤1" /></p>]]></content><author><name>NicoDora</name></author><category term="docker" /><summary type="html"><![CDATA[Docker 컨테이너와 이미지에 대해 간단히 살펴보고 macOS환경에서 Docker를 설치해봅시다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-logo.png" /><media:content medium="image" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-logo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">NestJS 설치 및 시작하기</title><link href="http://localhost:4000/nestjs/NestJS-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="NestJS 설치 및 시작하기" /><published>2024-03-29T09:57:00+09:00</published><updated>2024-03-29T09:57:00+09:00</updated><id>http://localhost:4000/nestjs/NestJS-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/nestjs/NestJS-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"><![CDATA[<ol id="markdown-toc">
  <li><a href="#시작하기-전에" id="markdown-toc-시작하기-전에">시작하기 전에</a></li>
  <li><a href="#nestjs-설치하기" id="markdown-toc-nestjs-설치하기">NestJS 설치하기</a></li>
  <li><a href="#nestjs-기본-프로젝트-구조-살펴보기" id="markdown-toc-nestjs-기본-프로젝트-구조-살펴보기">NestJS 기본 프로젝트 구조 살펴보기</a></li>
  <li><a href="#프로젝트-실행하기" id="markdown-toc-프로젝트-실행하기">프로젝트 실행하기</a></li>
  <li><a href="#마치며" id="markdown-toc-마치며">마치며</a></li>
</ol>

<h2 id="시작하기-전에">시작하기 전에</h2>

<p>NestJS를 설치하기 위해서는 <span style="color:rgb(65, 126, 56)"><b>Node.js</b></span>와 <span style="color:#CC3534"><b>npm</b></span>이 설치되어 있어야 합니다. 만약 설치되어 있지 않다면 <a href="https://nodejs.org/en/download">Node.js 공식 홈페이지</a>에서 Node.js를 설치해주세요.<br />
(Node.js를 설치하면 npm도 함께 설치됩니다.)</p>

<p><br />
Node.js 공식 다운로드 페이지에 들어가면 아래와 같은 화면이 보이게 됩니다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/nodejs-download-page.png" alt="Node.js 공식 홈페이지" /></p>

<p>LTS 버전과 Current 버전이 있는데, LTS 버전은 장기 지원되는 안정적인 버전이고 Current 버전은 최신 기능이 추가된 버전입니다.<br />
Current 버전에서는 예상치 못한 에러가 발생할 수 있으므로 보통은 LTS 버전을 권장합니다.</p>

<p>그 다음으로 본인이 사용중인 컴퓨터 환경을 선택하고 다운로드 해주시면 됩니다!</p>

<blockquote>
  <p>참고로 필자는 ARM 아키텍처를 사용한 애플 실리콘이 탑재된 macOS를 사용하고 있어 위 화면처럼 선택했습니다.</p>
</blockquote>

<p><br />
설치가 완료되었다면 터미널을 열어 아래 명령어를 입력해 Node.js와 npm이 정상적으로 설치되었는지 확인해봅시다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># file: "terminal"</span>
node <span class="nt">-v</span>
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/node-version-check.png" width="500" alt="node 버전 확인" /></p>

<p><br /></p>
<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># file: "terminal"</span>
npm <span class="nt">-v</span>
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/npm-version-check.png" width="500" alt="npm 버전 확인" /></p>

<p><br />
명령어를 입력했을 때 Node.js와 npm의 버전이 출력된다면 정상적으로 설치가 완료된 것입니다.</p>

<p>그럼 이제 NestJS를 설치하러 가봅시다!
<br /></p>

<h2 id="nestjs-설치하기">NestJS 설치하기</h2>

<p><a href="https://docs.nestjs.com">NestJS 공식 문서</a>를 참고하여 해당 포스트를 작성하니 공식 문서를 함께 참고하시면서 따라와주세요. 😊</p>

<p><br />
먼저 NestJS를 설치할 디렉토리를 생성하고 해당 디렉토리로 이동합니다.</p>

<p>저는 간단하게 <code class="language-plaintext highlighter-rouge">nest-project</code>라는 이름으로 디렉토리를 생성해봤습니다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/create-directory.png" width="500" alt="디렉토리 생성" />
<br />
<br />
<br />
그리고 해당 디렉토리 위치에서 아래 명령어를 입력해 <b>NestJS CLI</b><sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>를 설치합니다.
<br />
<br /></p>
<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># file: "NestJS CLI 설치"</span>
npm i <span class="nt">-g</span> @nestjs/cli
</code></pre></div></div>

<blockquote>
  <p>여기서 <code class="language-plaintext highlighter-rouge">-g</code> 옵션은 글로벌 설치를 의미합니다. 글로벌 설치를 하게 되면 어디서든 해당 패키지를 사용할 수 있습니다.</p>
</blockquote>

<p><br />
NestJS CLI를 설치하고 <code class="language-plaintext highlighter-rouge">nest</code>명령어를 입력하면 아래와 같이 사용할 수 있는 명령어들이 출력됩니다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/nest-command.png" alt="nest 명령어 확인" />
<br />
<br />
<br />
이제 <code class="language-plaintext highlighter-rouge">nest new {project-name}</code> 명령어를 통해 새로운 NestJS 프로젝트를 생성해봅시다.</p>

<p>필자는 <code class="language-plaintext highlighter-rouge">blog-nest</code>라는 이름으로 프로젝트를 생성해보겠습니다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/nest-new-project.png" width="700" alt="nest new 명령어로 프로젝트 생성" /></p>

<p>패키지 매니저를 선택하라는 메시지가 나오는데 필자는 <code class="language-plaintext highlighter-rouge">npm</code>을 선택했습니다.<br />
(화살표 키를 이용해 선택하고 엔터키를 누르면 됩니다.)
<br />
<br />
<br /></p>

<p class="figcaption"><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/new-project-create-loading.png" width="700" alt="프로젝트 생성중" /><br />
프로젝트 생성중인 모습</p>

<p><br />
프로젝트 생성이 완료되면 아래와 같이 성공적으로 프로젝트가 생성되었다고 메세지가 출력되네요!</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/install-success.png" width="700" alt="프로젝트 생성 성공" /></p>

<p><br />
이제 <code class="language-plaintext highlighter-rouge">code .</code> 명령어를 통해 해당 프로젝트 디렉토리를 VSCode에서 열어 구조를 살펴보러 가봅시다.</p>

<h2 id="nestjs-기본-프로젝트-구조-살펴보기">NestJS 기본 프로젝트 구조 살펴보기</h2>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/open-vscode.png" width="300" alt="VSCode에서 프로젝트 열기" /></p>

<p>VSCode에서 자세히 살펴보면 위 사진처럼 <code class="language-plaintext highlighter-rouge">blog-nest</code>라는 프로젝트 디렉토리가 생성되었고, 그 안에 노드 모듈과 src/ 디렉토리 안에 NestJS의 핵심 파일이 생성된 것을 확인할 수 있습니다.</p>

<p><br /></p>
<pre><code class="language-none">nest-project
└─ blog-nest
   ├─ src
   │  ├─ app.controller.spec.ts
   │  ├─ app.controller.ts
   │  ├─ app.module.ts
   │  ├─ app.service.ts
   │  └─ main.ts
   ├─ test
   │  ├─ app.e2e-spec.ts
   │  └─ jest-e2e.json
   ├─ .eslintrc.js
   ├─ .prettierrc
   ├─ README.md
   ├─ nest-cli.json
   ├─ package-lock.json
   ├─ package.json
   ├─ tsconfig.build.json
   └─ tsconfig.json
</code></pre>
<p class="figcaption">project tree</p>

<p><br />
핵심 파일들의 간략한 개요:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">파일명</th>
      <th style="text-align: left">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">app.controller.ts</code></td>
      <td style="text-align: left">컨트롤러 파일로, 클라이언트의 요청을 받아 처리하는 역할을 합니다.</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">app.controller.spec.ts</code></td>
      <td style="text-align: left">컨트롤러의 테스트 코드를 작성하는 파일입니다.</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">app.module.ts</code></td>
      <td style="text-align: left">애플리케이션의 루트 모듈입니다.</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">app.service.ts</code></td>
      <td style="text-align: left">서비스 파일로, 비즈니스 로직을 처리하는 역할을 합니다.</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">main.ts</code></td>
      <td style="text-align: left">Nest 애플리케이션 인스턴스를 생성하기 위해 핵심 함수 <code class="language-plaintext highlighter-rouge">NestFactory</code>를 사용하는 애플리케이션의 엔트리 파일입니다.</td>
    </tr>
  </tbody>
</table>

<p><br />
NestJS로 프로젝트를 진행하기 위해선 반드시 Controller, Service, Module을 이해하고 있어야 합니다…!<br />
지금 모두 설명하기에는 무리가 있으니 이에 대한 자세한 내용은 다음 포스트에서 다루도록 하겠습니다.</p>

<h2 id="프로젝트-실행하기">프로젝트 실행하기</h2>

<p>이제 프로젝트를 실행해 볼텐데, <code class="language-plaintext highlighter-rouge">package.json</code> 파일을 열어봅시다.</p>

<p><br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/package-json-scripts.png" alt="package.json 파일" /></p>

<p><code class="language-plaintext highlighter-rouge">scripts</code> 부분을 보면 다양한 명령어들이 적혀있는데, <code class="language-plaintext highlighter-rouge">npm run</code>과 함께 해당 명령어를 입력하면 옵션에 따라 다르게 서버를 실행할 수 있습니다.</p>

<p>일단은 <code class="language-plaintext highlighter-rouge">npm run start:dev</code> 명령어를 입력해 개발 서버를 실행해봅시다.</p>

<p>dev 옵션으로 서버를 실행하면 파일이 변경될 때마다 자동으로 서버가 재시작됩니다.<br />
개발중에는 위 명령어를 사용하여 서버를 실행하는 것을 추천합니다.
<br />
<br />
<br />
혹시나 아래와 같은 에러가 발생한다면 <code class="language-plaintext highlighter-rouge">cd {프로젝트 이름}</code> 명령어를 통해 프로젝트 디렉토리 안으로 이동 한 후 명령어를 입력해주세요!</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/missing-script-error.png" alt="missing script error" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm ERR! Missing script: "start:dev"
npm ERR! 
npm ERR! To see a list of scripts, run:
npm ERR!   npm run

npm ERR! A complete log of this run can be found in: /Users/nicodora/.npm/_logs/2024-03-28T12_55_04_707Z-debug-0.log
</code></pre></div></div>
<p><br />
<br />
서버를 성공적으로 실행했다면 아래와 같이 서버가 정상적으로 실행되었다는 메세지가 출력됩니다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/server-start-success.png" alt="서버 실행 성공" />
<br />
<br />
<br />
브라우저에서 <a href="http://localhost:3000"><code class="language-plaintext highlighter-rouge">http://localhost:3000</code></a> 혹은 <code class="language-plaintext highlighter-rouge">http://127.0.0.1:3000</code>으로 접속하면 아래와 같이 <code class="language-plaintext highlighter-rouge">Hello World!</code>라는 메세지가 출력되는 것을 확인할 수 있습니다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/localhost.png" width="700" alt="localhost 접속" /></p>

<h2 id="마치며">마치며</h2>

<p>오늘은 NestJS를 설치하고 기본 구조를 살펴보며 <code class="language-plaintext highlighter-rouge">Hello World!</code>서버를 실행시켜봤습니다.
<br />
<br />
NestJS를 설치하고 단 한 줄의 코드를 작성하지 않았음에도 간단하게 서버를 구동할 수 있었습니다. 👍<br />
(역시 킹갓 NestJS 😎)</p>

<p>다음 포스트에서는 NestJS의 핵심인 Controller, Service, Module에 대해 자세히 알아보고 직접 코드를 작성해보는 시간을 갖도록 하겠습니다.</p>

<p>그럼 다음 포스트에서 뵙겠습니다! 뾰로롱~
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/frieren1.gif" width="300" height="300" alt="프리렌 움짤1" /></p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>CLI(Command Line Interface)는 명령어를 통해 프로그램을 제어하는 인터페이스를 의미합니다. NestJS CLI는 NestJS 프로젝트를 생성하고 관리하는 명령어를 제공합니다. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>NicoDora</name></author><category term="nestjs" /><summary type="html"><![CDATA[NestJS를 설치하고 기본 구조를 살펴보며 NestJS를 사용해서 프로젝트를 시작해봅시다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/nestjs-logo.png" /><media:content medium="image" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/nestjs-logo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">NestJS를 선택한 이유 (NestJS란?)</title><link href="http://localhost:4000/nestjs/NestJS%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%9D%B4%EC%9C%A0/" rel="alternate" type="text/html" title="NestJS를 선택한 이유 (NestJS란?)" /><published>2024-03-22T21:20:00+09:00</published><updated>2024-03-22T21:20:00+09:00</updated><id>http://localhost:4000/nestjs/NestJS%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%9D%B4%EC%9C%A0</id><content type="html" xml:base="http://localhost:4000/nestjs/NestJS%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%9D%B4%EC%9C%A0/"><![CDATA[<ol id="markdown-toc">
  <li><a href="#nestjs란" id="markdown-toc-nestjs란">NestJS란?</a></li>
  <li><a href="#nestjs를-선택하기-전에" id="markdown-toc-nestjs를-선택하기-전에">NestJS를 선택하기 전에</a></li>
  <li><a href="#nestjs를-선택한-이유" id="markdown-toc-nestjs를-선택한-이유">NestJS를 선택한 이유</a></li>
  <li><a href="#지금부터는" id="markdown-toc-지금부터는">지금부터는</a></li>
</ol>

<h2 id="nestjs란">NestJS란?</h2>

<p>NestJS는 효율적이고 확장 가능한 Node.js 서버 측 애플리케이션을 구축하기 위한 프레임워크입니다. 진보적인 자바스크립트를 사용하고, TypeScript로 구축되어 완전히 지원하며(순수 자바스크립트로도 가능), OOP(Object Oriented Programming)<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, FP(Functional Programming)<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>, FRP(Functional Reactive Programming)<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>의 요소를 결합합니다.</p>

<p>내부적으로 Nest는 Express(기본값)와 같은 강력한 HTTP 서버 프레임워크를 사용하며, 선택적으로 Fastify도 사용하도록 구성할 수 있습니다!</p>

<p>Nest는 이러한 일반적인 Node.js 프레임워크(Express/Fastify)보다 높은 수준의 추상화를 제공할 뿐만 아니라 개발자에게 직접 API를 노출합니다. 따라서 개발자는 기본 플랫폼에서 사용할 수 있는 수많은 타사 모듈을 자유롭게 사용할 수 있습니다.</p>

<p><i><a href="https://docs.nestjs.com/">공식 문서</a> 참고.</i>
<br /></p>

<h2 id="nestjs를-선택하기-전에">NestJS를 선택하기 전에</h2>

<p>Modern-Agile 6기 백엔드로 활동하며 메인 프로젝트(<span style="color:#FF772B">멘보샤 프로젝트</span>)를 진행하였습니다.</p>

<p>프로젝트를 진행할 때 어떤 프레임워크를 사용할지에 대해 백엔드 팀원분들과 논의를 하였고, 결론적으로는 NestJS를 사용하기로 결정하였습니다. 그렇다면 저희가 왜 NestJS를 사용하게 되었을까요? 지금부터 그 이유를 다시 생각해보며 끄적여보겠습니다.
<br />
<br />
먼저, 모던애자일은 웹개발을 하고 싶은 열정은 가지고 있지만 어떻게 시작해야할지 막막한 사람들을 위해 애자일 방법론을 기반으로 웹 개발을 함께 배우는 방법을 제시하는 전문 동아리 입니다.<br />
때문에 다른 사람들도 아직 백엔드를 할지 프론트엔드를 할지조차 정하지 못한 상태로 들어오는 경우가 많아 백,프론트 두 곳에서 모두 사용할 수 있는 javascript를 사용해서 코딩테스트를 풀며 언어에 익숙해지는 시간을 갖게 되는데, 그러다보니 자연스럽게 미니 프로젝트에서는 javascript를 사용하는 node.js기반의 Express 프레임워크를 채택하게 되었습니다.
<br />
<br />
이제, 메인 프로젝트를 진행해야하는 시간이 다가왔습니다.<br />
그동안에 Express를 사용해 왔었는데 메인 프로젝트를 진행할때는 다른 프레임워크를 사용할지 아니면 Express를 계속 사용할지에 대해 논의를 하였습니다.<br />
사실 ‘새로운 프레임워크를 배우면서 동시에 프로젝트에 적용하는게 힘들지 않을까?’ 라는 두려움에 Express를 계속 사용하고 싶었지만… Express를 사용하면서 느꼈던 불편함도 해결해보고 싶었고 새로운 기술을 배우며 프로그래밍에 대한 시야를 넓히고 싶었기에 새로운 프레임워크를 사용하기로 결정하였습니다.
<br />
<br />
<br /></p>
<blockquote>
  <p><b>Express를 사용하면서 느낀 가장 큰 단점은 “하나부터 열까지 개발자가 정하고 구현해야 한다” 였습니다.</b></p>
</blockquote>

<p><br />
Express는 제약이 없어 구조가 자유롭다는 장점이 있지만, 이는 개발자가 코드를 어떻게 구조화할지에 대한 명확한 가이드라인이 없다는 것을 의미합니다. 미니 프로젝트임에도 불구하고 디자인 패턴부터 에러 핸들링, 라이프사이클 관리까지 모든 것을 개발자가 스스로 정하고 구현해야 했기에 매우 귀찮고 힘들었습니다.
<br />
개발자가 개입할 수 있는 부분이 많다는 건 결국 개발자가 해야할 일이 많아지고 오류가 발생할 확률도 높아지는 것이니까요.</p>

<p>결국 위와 같은 이유로 Express는 프로젝트 규모가 커지면 사용하기 어렵다는 결론에 도달하게 되었습니다.
<br /></p>

<h2 id="nestjs를-선택한-이유">NestJS를 선택한 이유</h2>

<p>이제 Express의 단점을 보완시켜줄 프레임워크로 NestJS를 선택한 이유에 대해 설명드리겠습니다.</p>

<p><b>1. 구조화된 아키텍처</b><br />
NestJS는 Provider, Module, Controller, Service, Middleware, Pipe, Guard, Decorator, Filter, Exception Filter 등의 요소들을 제공하며, 이러한 요소들을 조합하여 구조화된 아키텍처를 구축할 수 있습니다. 이러한 구조화된 아키텍처는 프로젝트 규모가 커질수록 코드의 가독성과 유지보수성을 높여줍니다.<br />
기능 구현하기도 바쁜 저희 팀에게는 매우 큰 장점이 될 것이라고 생각되었습니다.
<br />
<br />
<b>2. TypeScript 사용</b><br />
NestJS는 TypeScript로 쓸 것을 가정하고 만들어진 프레임워크입니다. TypeScript를 사용하면 정적 타입 검사를 통해 런타임 에러를 줄일 수 있고, 코드의 가독성을 높일 수 있습니다.
<br />
<br />
<b>3. 잘 정리되어 있는 공식 문서</b><br />
처음에 데코레이터, 파이프, 프로바이더 등의 용어가 생소했지만, 공식 문서가 잘 정리되어 있다는 점에서 NestJS를 안심하고 선택할 수 있었던 것 같습니다.
<br />
<br />
결론적으로 NestJS를 사용하여 메인 프로젝트를 진행하게 된 것이 좋은 선택이었다고 생각합니다.</p>

<h2 id="지금부터는">지금부터는</h2>
<p><del>그 뒤는 안돼 임마!</del><br />
NestJS를 사용하여 프로젝트에서 제가 구현했던 기능들부터 다른 팀원분들이 구현했던 기능들도 직접 한번 구현해보면서<br />
차근차근 포스팅 해보겠습니다! 😊</p>

<p>그럼 다음 포스트에서 뵙겠습니다 뾰로롱~
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/frieren1.gif" width="300" height="300" alt="프리렌 움짤1" /></p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>객체 지향 프로그래밍(Object Oriented Programming, OOP)은 컴퓨터 프로그래밍의 패러다임 중 하나로, 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 “객체”들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고 데이터를 처리할 수 있다. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>함수형 프로그래밍(Functional Programming, FP)은 계산을 수학적 함수의 평가로 간주하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임이다. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>함수형 반응형 프로그래밍(Functional Reactive Programming, FRP)은 함수형 프로그래밍과 반응형 프로그래밍을 결합한 프로그래밍 패러다임이다. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>NicoDora</name></author><category term="nestjs" /><summary type="html"><![CDATA[NestJS가 무엇인지 알아보고 Modern-Agile 6기 메인 프로젝트에서 왜 NestJS를 채택했는지 알아봅시다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-22-NestJS를-선택한-이유/nestjs-logo.png" /><media:content medium="image" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-22-NestJS를-선택한-이유/nestjs-logo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>