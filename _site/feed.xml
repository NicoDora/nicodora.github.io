<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-03-18T18:03:57+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">NicoDora</title><subtitle>백엔드 개발을 중심으로 포스트 하고 있는 NicoDora의 블로그입니다.</subtitle><author><name>NicoDora</name></author><entry><title type="html">GitHub Actions로 CI/CD 구축하기</title><link href="http://localhost:4000/github/2025/03/18/GitHub-Actions%EB%A1%9C-CICD-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0.html" rel="alternate" type="text/html" title="GitHub Actions로 CI/CD 구축하기" /><published>2025-03-18T18:03:00+09:00</published><updated>2025-03-18T18:03:00+09:00</updated><id>http://localhost:4000/github/2025/03/18/GitHub-Actions%EB%A1%9C-CICD-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/github/2025/03/18/GitHub-Actions%EB%A1%9C-CICD-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0.html"><![CDATA[<ol id="markdown-toc">
  <li><a href="#지금까지의-이야기" id="markdown-toc-지금까지의-이야기">지금까지의 이야기</a></li>
  <li><a href="#cicd란" id="markdown-toc-cicd란">CI/CD란?</a></li>
  <li><a href="#actions-secrets-설정하기" id="markdown-toc-actions-secrets-설정하기">Actions Secrets 설정하기</a></li>
  <li><a href="#github-actions-workflow-생성하기" id="markdown-toc-github-actions-workflow-생성하기">GitHub Actions Workflow 생성하기</a></li>
  <li><a href="#github-actions-실행-확인하기" id="markdown-toc-github-actions-실행-확인하기">GitHub Actions 실행 확인하기</a></li>
  <li><a href="#마치며" id="markdown-toc-마치며">마치며</a></li>
</ol>

<h2 id="지금까지의-이야기">지금까지의 이야기</h2>

<p>이전 포스팅에서 AWS EC2에 Nginx와 Certbot을 설치하여 Let’s Encrypt SSL 인증서를 발급 및 자동 갱신까지 하는 방법에 대해 알아보았습니다. 서버를 구축하고 어느정도 사용해보시면 알겠지만, 서버 코드가 수정될 때 마다 수동으로 EC2에 접속하여 컨테이너를 내리고 수정된 코드를 이미지로 만들어 다시 컨테이너를 실행시키는 작업이 매우 비효율적이라는 것을 깨닫게 됩니다.
<br />
<br />
몇번 이 작업을 반복하다보면, ‘이 작업을 자동화 하면 좋겠다’ 하는 생각이 드실겁니다.<br />
보통 이러한 과정을 CI/CD라고 부르고, GitHub에서는 Actions라는 서비스를 통해 개발자들이 편하게 CI/CD를 구축할 수 있도록 환경을 제공하고 있습니다. 이번 포스팅에서는 GitHub Actions를 사용하여 CI/CD를 구축하는 방법에 대해 알아보겠습니다.</p>

<h2 id="cicd란">CI/CD란?</h2>

<p>CI/CD는 ‘Continuous Integration/Continuous Delivery’의 약자로, 지속적인 통합과 지속적인 배포를 의미합니다. 즉, 코드 변경 사항을 자동으로 빌드하고 테스트하여 배포하는 과정을 자동화한다 라고 생각하시면 됩니다.</p>

<ul>
  <li><b>CI (Continuous Integration) - 지속적인 통합</b>
    <ul>
      <li>개발자들이 작성한 코드를 정기적으로 통합하여 빌드하고 테스트하는 과정입니다. 이를 통해 코드의 품질을 높이고, 버그를 조기에 발견할 수 있습니다.</li>
    </ul>
  </li>
  <li><b>CD (Continuous Delivery) - 지속적인 배포</b>
    <ul>
      <li>CI 과정에서 빌드된 코드를 자동으로 배포하는 과정입니다. 이를 통해 코드 변경 사항을 빠르게 사용자에게 전달할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<p><br />
GitHub Actions는 이러한 CI/CD를 구현하기 위한 도구로, GitHub 저장소에서 직접 워크플로우를 정의하고 실행할 수 있습니다. GitHub는 개발자가 가장 많이 사용하는 서비스 중 하나이기 때문에 GitHub Actions에 대해 배우는 것은 크게 어렵지 않으실 겁니다.</p>

<h2 id="actions-secrets-설정하기">Actions Secrets 설정하기</h2>

<p>GitHub Actions를 사용하기 전에 먼저 GitHub 저장소에 <code class="language-plaintext highlighter-rouge">Secrets</code>를 설정해보려 합니다. GitHub Actions는 GitHub repository에 올린 <code class="language-plaintext highlighter-rouge">workflow/</code> 폴더 내의 파일을 통해 CI/CD를 실행하게 되는데 여기서 Docker ID/PW나 AWS EC2에 SSH로 접속하기 위한 비밀번호 등과 같이 민감한 정보가 필요합니다.
<br />
<br />
GitHub에서는 이러한 민감한 정보를 <code class="language-plaintext highlighter-rouge">Secrets</code>라는 기능을 통해 안전하게 저장하고 사용할 수 있도록 지원하고 있습니다.
<br />
<br />
GitHub Secrets는 GitHub repository의 <code class="language-plaintext highlighter-rouge">Settings</code> &gt; <code class="language-plaintext highlighter-rouge">Secrets and variables</code> &gt; <code class="language-plaintext highlighter-rouge">Actions</code>에서 설정할 수 있습니다.
<br />
<br />
<img src="/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets.png" alt="GitHub Secrets 접속" />
<br />
<br /></p>

<p><code class="language-plaintext highlighter-rouge">Secrets</code> 탭에서 시크릿 환경변수를 관리할 수 있는데요. 여기서 <code class="language-plaintext highlighter-rouge">Environment secrets</code>, <code class="language-plaintext highlighter-rouge">Repository secrets</code>, <code class="language-plaintext highlighter-rouge">Organization secrets</code>라는 세가지 종류의 시크릿 환경변수를 보실 수 있습니다.</p>

<ul>
  <li><b>Environment secrets</b>
    <ul>
      <li>특정 환경에 대한 시크릿을 설정합니다.</li>
      <li>예) <code class="language-plaintext highlighter-rouge">development</code>, <code class="language-plaintext highlighter-rouge">staging</code>, <code class="language-plaintext highlighter-rouge">production</code> 등에 대한 시크릿.</li>
    </ul>
  </li>
  <li><b>Repository secrets</b>
    <ul>
      <li>특정 repository에 대한 시크릿을 설정합니다. 해당 repository에서 공통으로 사용되는 시크릿을 설정할 수 있습니다.</li>
      <li>예) <code class="language-plaintext highlighter-rouge">Docker ID/PW</code>, <code class="language-plaintext highlighter-rouge">AWS ID/PW</code>에 대한 시크릿.</li>
    </ul>
  </li>
  <li><b>Organization secrets</b>
    <ul>
      <li>조직에 대한 시크릿을 설정합니다. 조직 내의 모든 repository에서 공통으로 사용되는 시크릿을 설정할 수 있습니다.</li>
      <li>예) <code class="language-plaintext highlighter-rouge">AWS ID/PW</code>에 대한 시크릿.
<br />
<br /></li>
    </ul>
  </li>
</ul>

<p>본인의 상황에 맞게 시크릿을 설정하시면 되는데, 보통 <code class="language-plaintext highlighter-rouge">production</code>, <code class="language-plaintext highlighter-rouge">development</code>과 같이 환경을 나누어 관리하는 경우가 많기 때문에 <code class="language-plaintext highlighter-rouge">Environment secrets</code>를 사용하여 시크릿을 설정하는 것을 추천드립니다.
<br />
<br />
<code class="language-plaintext highlighter-rouge">development</code> 환경에서 사용할 시크릿을 설정해보겠습니다.<br />
<code class="language-plaintext highlighter-rouge">Manage environment secrets</code> 버튼을 클릭합니다.
<br />
<br />
<img src="/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets-setting.png" alt="GitHub Secrets 설정" />
<br />
<br />
<br />
<code class="language-plaintext highlighter-rouge">New environment</code> 를 클릭하여 새 Environments를 생성합니다.
<br />
<br />
<img src="/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets-new-environment.png" alt="GitHub Secrets New Environment" />
<br />
<br />
<br />
Environments에 대한 이름을 설정할 수 있는데, 저는 develop 브랜치의 CI/CD를 구현할 예정이므로 <code class="language-plaintext highlighter-rouge">development</code> 로 입력하겠습니다.<br />
입력 후 <code class="language-plaintext highlighter-rouge">Configure environment</code> 버튼을 클릭합니다.
<br />
<br />
<img src="/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets-new-environment-name.png" alt="GitHub Secrets New Environment Name" />
<br />
<br />
<br />
Environments가 생성되면 아래와 같은 화면이 보이게 됩니다.<br />
여기서 배포 보호 규칙을 설정할 수도 있지만 이 부분은 스킵하겠습니다. <code class="language-plaintext highlighter-rouge">Deployment branches and tags</code>에서 <code class="language-plaintext highlighter-rouge">Select branches and tags</code>로 바꿔 배포할 브랜치를 설정해보겠습니다.
<br />
<br />
<img src="/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets-new-environment-setting.png" alt="GitHub Secrets New Environment Setting" />
<br />
<br />
<br />
그런 다음 Environments를 사용할 브랜치를 추가하면 됩니다.<br />
저는 <code class="language-plaintext highlighter-rouge">develop</code> 브랜치를 추가하겠습니다.
<br />
<br />
<img src="/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets-new-environment-setting2.png" alt="GitHub Secrets New Environment Setting2" />
<br />
<br />
<img src="/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets-new-environment-setting3.png" alt="GitHub Secrets New Environment Setting3" />
<br />
<br />
<br />
이제 <code class="language-plaintext highlighter-rouge">development</code> 환경에 대한 설정이 완료되었으므로 시크릿 변수를 추가해봅시다.<br />
바로 아래 <code class="language-plaintext highlighter-rouge">Environment secrets</code> 탭에서 <code class="language-plaintext highlighter-rouge">New environment secret</code> 버튼을 클릭합니다.
<br />
<br />
<img src="/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets-new-environment-secret.png" alt="GitHub Secrets New Environment Secret" />
<br />
<br />
<br />
이름과 값을 입력할 수 있는 화면이 보이는데 여기에 CI/CD에 필요한 시크릿 변수를 추가하면 됩니다.<br />
참고로 한번 설정된 시크릿 변수는 수정만 가능하고 볼 수 없으므로 주의하시기 바랍니다.<br />
저는 <code class="language-plaintext highlighter-rouge">DOCKER_USERNAME</code>, <code class="language-plaintext highlighter-rouge">DOCKER_PASSWORD</code>, <code class="language-plaintext highlighter-rouge">EC2_HOST</code>, <code class="language-plaintext highlighter-rouge">EC2_USER</code>, <code class="language-plaintext highlighter-rouge">SSH_PRIVATE_KEY</code>를 추가하겠습니다.
<br />
<br />
<img src="/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-secrets-new-environment-secret-setting.png" alt="GitHub Secrets New Environment Secret Setting" />
<br />
<br />
<br />
<code class="language-plaintext highlighter-rouge">EC2_HOST</code>는 EC2의 <code class="language-plaintext highlighter-rouge">퍼블릭 IPv4 DNS</code>를, <code class="language-plaintext highlighter-rouge">EC2_USER</code>는 EC2에 접속하기 위한 사용자 이름을 입력하시면 됩니다.<br />
<code class="language-plaintext highlighter-rouge">SSH_PRIVATE_KEY</code>는 EC2에 접속하기 위한 개인키를 말하는데요. <code class="language-plaintext highlighter-rouge">.pem</code> 파일이나 <code class="language-plaintext highlighter-rouge">.ppk</code> 파일을 열어 개인키를 복사하여 붙여넣으면 됩니다.
<br />
<br />
macOS에서는 <code class="language-plaintext highlighter-rouge">cat</code> 명령어를 사용하여 개인키를 확인할 수 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># cat {파일위치}</span>
<span class="nv">$ </span><span class="nb">cat</span> ~/.ssh/your-key.pem
</code></pre></div></div>

<p><img src="/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/ec2-ssh-private-key.png" alt="ec2 ssh private key" />
<br />
📍 <b>ssh 키를 복사할 때는 반드시 Header와 Footer를 포함해서 복사해야 합니다!</b></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEAu06IpZklZ5W9L/AS56LAE95FvmmPhmO9MeyUItiw2jDfwaiR
...
-----END RSA PRIVATE KEY-----
</code></pre></div></div>

<h2 id="github-actions-workflow-생성하기">GitHub Actions Workflow 생성하기</h2>

<p>시크릿 변수를 모두 추가하셨다면 CI/CD를 실행할 파일을 생성해봅시다.<br />
GitHub Actions는 <code class="language-plaintext highlighter-rouge">.github/workflows</code> 폴더 내에 <code class="language-plaintext highlighter-rouge">yaml</code> 파일을 통해 CI/CD를 실행합니다.
<br />
<br />
프로젝트 repository 내에 <code class="language-plaintext highlighter-rouge">Actions</code> 탭에서 <code class="language-plaintext highlighter-rouge">New workflow</code> 버튼을 클릭하여 미리 정의된 템플릿을 사용할 수 있는데 대부분 템플릿을 사용하지 않고 직접 작성하시더라구요? 사실 템플릿을 사용할 만큼 파일을 작성하는게 어렵지 않아서 그런거 같습니다.<br />
그래서 저도 직접 작성해보려 합니다. 별로 어렵지 않으니… ㅎㅎ
<br />
<br />
일단 <code class="language-plaintext highlighter-rouge">.github/workflows</code> 폴더를 생성하고 그 안에 <code class="language-plaintext highlighter-rouge">.yml</code> 파일을 생성합니다.<br />
참고로 <code class="language-plaintext highlighter-rouge">.yml</code>, <code class="language-plaintext highlighter-rouge">.yaml</code> 둘다 같은 확장자이니 편하신걸로 사용하시면 됩니다. 만들어져 있는 production 환경 CI/CD 파일이 <code class="language-plaintext highlighter-rouge">.yml</code> 확장자라서 일관성을 위해 저도 <code class="language-plaintext highlighter-rouge">.yml</code>로 작성하겠습니다.<br />
파일 이름도 원하시는대로 작성하시면 되고, 저는 production 환경과 구분하기 위해 파일 이름은 <code class="language-plaintext highlighter-rouge">app-dev.yml</code>로 작성하겠습니다.
<br />
<br /></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># file: ".github/workflows/app-dev.yml"</span>
<span class="na">name</span><span class="pi">:</span> <span class="s">app-dev</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">develop</span><span class="pi">]</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">environment</span><span class="pi">:</span> <span class="s">development</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout repository</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set up Docker Buildx</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">docker/setup-buildx-action@v2</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Login to Docker Hub</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">docker/login-action@v2</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">username</span><span class="pi">:</span> <span class="s">${ { secrets.DOCKER_USERNAME } }</span>
          <span class="na">password</span><span class="pi">:</span> <span class="s">${ { secrets.DOCKER_PASSWORD } }</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build Docker image (development)</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">docker build --platform linux/amd64 -f Dockerfile.dev -t nicodora/honey-moa-dev:latest .</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Push Docker image</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">docker push nicodora/honey-moa-dev:latest</span>

      <span class="c1"># 배포 단계: EC2에 SSH로 접속하여 컨테이너 업데이트</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Deploy to EC2</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">appleboy/ssh-action@v0.1.8</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">host</span><span class="pi">:</span> <span class="s">${ { secrets.EC2_HOST } }</span>
          <span class="na">username</span><span class="pi">:</span> <span class="s">${ { secrets.EC2_USER } }</span>
          <span class="na">key</span><span class="pi">:</span> <span class="s">${ { secrets.SSH_PRIVATE_KEY } }</span>
          <span class="na">script</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s"># 기존 컨테이너 중지 및 삭제</span>
            <span class="s">sudo docker-compose -f docker-compose.dev.yaml down</span>

            <span class="s"># 오래된 이미지 정리</span>
            <span class="s">sudo docker rmi -f nicodora/honey-moa-dev:latest || true</span>

            <span class="s"># 최신 이미지 pull</span>
            <span class="s">sudo docker pull nicodora/honey-moa-dev:latest</span>

            <span class="s"># 최신 이미지로 Docker Compose 실행</span>
            <span class="s">sudo docker-compose -f docker-compose.dev.yaml up -d</span>
</code></pre></div></div>

<details>
<summary><b>코드 흐름</b></summary>
<div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">develop</code> 브랜치에 push가 발생하면 <code class="language-plaintext highlighter-rouge">app-dev.yml</code> 파일이 실행됩니다.</li>
      <li><code class="language-plaintext highlighter-rouge">ubuntu-latest</code> 환경에서 실행되며, <code class="language-plaintext highlighter-rouge">development</code> 환경을 사용합니다.</li>
      <li>도커에 로그인 하고 이미지를 빌드하여 <code class="language-plaintext highlighter-rouge">Docker Hub</code>에 푸시합니다.</li>
      <li><code class="language-plaintext highlighter-rouge">appleboy/ssh-action</code>을 사용하여 EC2에 SSH로 접속하여 컨테이너를 업데이트합니다.</li>
    </ul>
  </div>
</details>
<p><br />
<br />
이제 <code class="language-plaintext highlighter-rouge">app-dev.yml</code> 파일을 커밋하고 <code class="language-plaintext highlighter-rouge">develop</code> 브랜치에 푸시하면 CI/CD가 실행됩니다.</p>

<h2 id="github-actions-실행-확인하기">GitHub Actions 실행 확인하기</h2>

<p>Actions 탭에서 작성한 workflow 파일을 클릭해 보면 CI/CD가 실행되는 것을 확인할 수 있습니다.
<br />
<br />
<img src="/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-actions-run.png" alt="GitHub Actions 실행 확인" />
<br />
<br />
<br />
build 탭에 들어가보면 각 단계별로 자세한 로그를 확인할 수 있습니다.<br />
아래와 같이 ✅ 표시가 뜨면 성공적으로 실행된 것입니다!
<br />
<br />
<img src="/assets/img/github/2025-03-18-GitHub-Actions로-CICD-구축하기/github-actions-run2.png" alt="GitHub Actions 실행 확인2" /></p>

<h2 id="마치며">마치며</h2>

<p>이번 포스팅에서는 GitHub Actions를 사용하여 CI/CD를 구축하는 방법에 대해 알아보았습니다.<br />
큰 노력 없이 CI/CD를 구축하여 배포 자동화를 할 수 있기에 지속적으로 코드를 배포한다고 하면 거의 필수 작업이라고 생각합니다.</p>

<p>그럼 다음 포스트에서 뵙겠습니다! 뾰로롱~
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/frieren1.gif" width="300" height="300" alt="프리렌 움짤1" /></p>]]></content><author><name>NicoDora</name></author><category term="github" /><summary type="html"><![CDATA[GitHub Actions를 사용하여 CI/CD를 구축하는 방법에 대해 알아보겠습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/github/2025-03-18-GitHub-Actions%EB%A1%9C-CICD-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0/github-actions.png" /><media:content medium="image" url="http://localhost:4000/assets/img/github/2025-03-18-GitHub-Actions%EB%A1%9C-CICD-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0/github-actions.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">AWS EC2에서 Nginx와 Certbot으로 Let’s encrypt SSL 인증서 발급하기</title><link href="http://localhost:4000/aws/2025/03/07/AWS-EC2%EC%97%90%EC%84%9C-Nginx%EC%99%80-Certbot%EC%9C%BC%EB%A1%9C-Lets-encrypt-SSL-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0.html" rel="alternate" type="text/html" title="AWS EC2에서 Nginx와 Certbot으로 Let’s encrypt SSL 인증서 발급하기" /><published>2025-03-07T14:31:00+09:00</published><updated>2025-03-07T14:31:00+09:00</updated><id>http://localhost:4000/aws/2025/03/07/AWS-EC2%EC%97%90%EC%84%9C-Nginx%EC%99%80-Certbot%EC%9C%BC%EB%A1%9C-Lets-encrypt-SSL-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/aws/2025/03/07/AWS-EC2%EC%97%90%EC%84%9C-Nginx%EC%99%80-Certbot%EC%9C%BC%EB%A1%9C-Lets-encrypt-SSL-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0.html"><![CDATA[<ol id="markdown-toc">
  <li><a href="#들어가기-전에" id="markdown-toc-들어가기-전에">들어가기 전에</a></li>
  <li><a href="#사전-준비-환경" id="markdown-toc-사전-준비-환경">사전 준비 환경</a></li>
  <li><a href="#dns-체크" id="markdown-toc-dns-체크">DNS 체크</a></li>
  <li><a href="#docker-composeyaml-작성" id="markdown-toc-docker-composeyaml-작성">docker-compose.yaml 작성</a></li>
  <li><a href="#nginxconf-파일-작성" id="markdown-toc-nginxconf-파일-작성">nginx.conf 파일 작성</a></li>
  <li><a href="#nginx-임시-실행" id="markdown-toc-nginx-임시-실행">Nginx 임시 실행</a></li>
  <li><a href="#certbot으로-ssl-인증서-발급" id="markdown-toc-certbot으로-ssl-인증서-발급">Certbot으로 SSL 인증서 발급</a></li>
  <li><a href="#docker-composeyaml-파일-업데이트" id="markdown-toc-docker-composeyaml-파일-업데이트">docker-compose.yaml 파일 업데이트</a></li>
  <li><a href="#nginxconf-파일-업데이트" id="markdown-toc-nginxconf-파일-업데이트">nginx.conf 파일 업데이트</a></li>
  <li><a href="#docker-compose-실행" id="markdown-toc-docker-compose-실행">docker-compose 실행</a></li>
  <li><a href="#마치며" id="markdown-toc-마치며">마치며</a></li>
</ol>

<h2 id="들어가기-전에">들어가기 전에</h2>

<p>프로젝트를 진행중에 백엔드 개발서버를 배포해야 할 상황이 와서 급하게 EC2와 RDS를 만들고 SSL 인증서를 발급받으려고 할 때 갑자기 이런 생각이 들었습니다. <b>“이거 블로그에 정리해두면 좋겠다!”</b> 라고…
<br />
<br />
백엔드 서버의 배포과정을 A to Z로 정리하면 좋겠지만…<br />
이미 AWS 세팅은 대부분 완료된 상태라서, SSL 인증서 발급과정만 정리해보려고 합니다.
<br />
<br />
사실 SSL 인증서 발급 부분도 처음 적용하는 사람 입장에서는 헷갈릴 수 있는 부분이 많아서, 블로그에 정리해두면 분명 다른 사람들에게 도움이 될 거라고 생각합니다! (실제로 저도 처음에는 많이 헤맸거든요… ㅎㅎ;;)</p>

<h2 id="사전-준비-환경">사전 준비 환경</h2>

<p>일단 저의 환경은 아래와 같습니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/dev-server-architecture1.png" alt="dev 서버 아키텍쳐1" /></p>

<ul>
  <li>AWS EC2 인스턴스 (Ubuntu)</li>
  <li>도메인 구매 및 연결 (가비아, AWS Route53)</li>
  <li>EC2에서 Docker로 백엔드 서버 실행
<br />
<br />
<br />
해당 환경을 다음과 같이 수정해보려 합니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/dev-server-architecture2.png" alt="dev 서버 아키텍쳐2" /></li>
</ul>

<p><br />
여기서 도메인 구매는 필수가 아니기 때문에 EC2 인스턴스에 할당된 퍼블릭 IPv4 주소를 사용해도 괜찮지만, 저는 도메인을 구매했기 때문에 도메인을 사용해서 진행하겠습니다.
<br />
<br />
Docker를 사용하지 않고 EC2 인스턴스에 Nginx를 설치하고 SSL 인증서를 발급받는 방법도 있지만, Docker를 사용하면 더 간편하게 관리할 수 있기 때문에 저는 Docker 사용을 추천드립니다.
<br />
<br />
EC2 인스턴스에 Docker 및 docker-compose 설치는 아래 명령어를 차례대로 입력하시면 됩니다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1-1. 프로그램 설치 전 우분투 시스템 패키지 업데이트</span>
<span class="nv">$ </span><span class="nb">sudo </span>apt-get update

<span class="c"># 1-2. 필요한 패키지 설치</span>
<span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>apt-transport-https ca-certificates curl gnupg-agent software-properties-common

<span class="c"># 1-3. Docker의 공식 GPG 키 추가</span>
<span class="nv">$ </span>curl <span class="nt">-fsSL</span> https://download.docker.com/linux/ubuntu/gpg | <span class="nb">sudo </span>apt-key add -

<span class="c"># 1-4. Docker의 공식 apt 저장소 추가</span>
<span class="nv">$ </span><span class="nb">sudo </span>add-apt-repository <span class="s2">"deb [arch=amd64] https://download.docker.com/linux/ubuntu </span><span class="si">$(</span>lsb_release <span class="nt">-cs</span><span class="si">)</span><span class="s2"> stable"</span>

<span class="c"># 1-5. 시스템 패키지 업데이트</span>
<span class="nv">$ </span><span class="nb">sudo </span>apt-get update

<span class="c"># 1-6. Docker 설치</span>
<span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>docker-ce docker-ce-cli containerd.io

<span class="c"># 2-1. Docker Compose 설치</span>
<span class="nv">$ </span><span class="nb">sudo </span>curl <span class="nt">-L</span> <span class="s2">"https://github.com/docker/compose/releases/download/1.27.4/docker-compose-</span><span class="si">$(</span><span class="nb">uname</span> <span class="nt">-s</span><span class="si">)</span><span class="s2">-</span><span class="si">$(</span><span class="nb">uname</span> <span class="nt">-m</span><span class="si">)</span><span class="s2">"</span> <span class="nt">-o</span> /usr/local/bin/docker-compose

<span class="c"># 2-2. 다운로드 한 파일에 권한 설정</span>
<span class="nv">$ </span><span class="nb">sudo chmod</span> +x /usr/local/bin/docker-compose

<span class="c"># 2-3. Docker Compose 버전 확인 (정상적으로 설치되었는지 확인)</span>
<span class="nv">$ </span>docker-compose <span class="nt">--version</span>
</code></pre></div></div>

<p><a href="https://velog.io/@jjeongdong/Devops-Docker-Compose%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-EC2%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%B0%B0%ED%8F%AC#ec2-linux%EC%97%90-docker--docker-compose-%EC%84%A4%EC%B9%98">출처</a></p>

<h2 id="dns-체크">DNS 체크</h2>

<p>도메인을 구매하신 분들이라면 DNS가 정상적으로 설정되었는지 확인해보셔야 합니다.<br />
터미널에서 아래 명령어를 입력하시면 됩니다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dig {도메인}</span>
<span class="nv">$ </span>dig dev.honeymoa.kr
</code></pre></div></div>

<p>정상적으로 설정되었다면 아래와 같이 <code class="language-plaintext highlighter-rouge">status</code>가 <code class="language-plaintext highlighter-rouge">NOERROR</code>로 나오고, <code class="language-plaintext highlighter-rouge">ANSWER SECTION</code>에 도메인과 연결된 IP 주소가 나옵니다.
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/dns-check.png" alt="DNS 설정 확인" />
<br />
<br />
혹시나 <code class="language-plaintext highlighter-rouge">status</code>가 <code class="language-plaintext highlighter-rouge">NXDOMAIN</code>으로 나오신다면 도메인 설정이 잘못되었거나, DNS 서버에 도메인 정보가 전파되지 않은 것입니다.<br />
다시한번 도메인 설정을 확인하시고, 올바르게 설정하셨다면 DNS 서버에 도메인 정보가 전파될 때까지 기다려주세요.</p>

<h2 id="docker-composeyaml-작성">docker-compose.yaml 작성</h2>

<p><span style="color:#808080"> 📍 <em>지금부터 파일 작성은 EC2 인스턴스에 접속했을 때의 <b>루트 디렉토리(/home/ubuntu)</b>에서 진행되니 유의해주세요!</em> </span></p>

<p>레거시한 방법으로 SSL 인증서를 발급하려면 EC2 인스턴스에 Nginx를 설치하고, Certbot을 설치해야 하지만,<br />
Docker를 사용하면 Nginx와 Certbot을 컨테이너로 한번에 실행할 수 있습니다.
<br />
<br />
아래와 같이 <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> 파일을 작성해줍니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># file: "docker-compose.yaml"</span>
<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.7'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">nginx</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:1.15-alpine</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">80:80'</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./nginx/nginx.conf:/etc/nginx/nginx.conf</span>
      <span class="pi">-</span> <span class="s">./nginx/www/certbot:/var/www/certbot</span>
      <span class="pi">-</span> <span class="s">./nginx/logs:/var/log/nginx</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">unless-stopped</span>

  <span class="na">certbot</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">certbot/certbot</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">certbot</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./nginx/www/certbot:/var/www/certbot</span>
      <span class="pi">-</span> <span class="s">./nginx/ssl:/etc/letsencrypt</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">certonly --webroot --webroot-path=/var/www/certbot -d {도메인}</span>
</code></pre></div></div>
<p><br />
간단하게 위 코드에 대해서 설명드리겠습니다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">nginx</code> 서비스
    <ul>
      <li><code class="language-plaintext highlighter-rouge">image</code>: 사용할 Nginx 이미지</li>
      <li><code class="language-plaintext highlighter-rouge">container_name</code>: 컨테이너 이름</li>
      <li><code class="language-plaintext highlighter-rouge">ports</code>: 호스트와 컨테이너의 포트 매핑 (80:80)</li>
      <li><code class="language-plaintext highlighter-rouge">volumes</code>: 호스트와 컨테이너의 디렉토리 매핑</li>
      <li><code class="language-plaintext highlighter-rouge">restart</code>: 컨테이너가 중지되었을 때 재시작할 정책 설정</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">certbot</code> 서비스
    <ul>
      <li><code class="language-plaintext highlighter-rouge">image</code>: 사용할 Certbot 이미지</li>
      <li><code class="language-plaintext highlighter-rouge">container_name</code>: 컨테이너 이름</li>
      <li><code class="language-plaintext highlighter-rouge">volumes</code>: 호스트와 컨테이너의 디렉토리 매핑</li>
      <li><code class="language-plaintext highlighter-rouge">command</code>: Certbot 명령어 (인증서 발급)
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h2 id="nginxconf-파일-작성">nginx.conf 파일 작성</h2>

<p><code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> 파일에서 볼륨 마운트 설정을 보면 <code class="language-plaintext highlighter-rouge">nginx/</code> 디렉토리가 필요한 것을 확인할 수 있습니다.
<br /></p>

<p class="note">전체적인 디렉토리 구조는 아래와 같습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/home/ubuntu
├── docker-compose.yaml
├── nginx
│   ├── nginx.conf
│   ├── ssl/
│   │   ├── (certbot 인증서)
│   ├── logs/
│   └── www/
│       └── certbot/
└── .env
</code></pre></div></div>
<p><br /></p>

<p>아래와 같이 <b><code class="language-plaintext highlighter-rouge">nginx</code></b> 디렉토리를 생성해줍니다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir </span>nginx
</code></pre></div></div>

<p><br />
그리고 <code class="language-plaintext highlighter-rouge">nginx</code> 디렉토리 안에 <b><code class="language-plaintext highlighter-rouge">nginx.conf</code></b> 파일을 생성해줍니다.<br />
<code class="language-plaintext highlighter-rouge">nginx.conf</code> 파일은 Nginx가 실행될 때 사용하는 설정 파일로, 아래와 같이 작성해줍니다.</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># file: "nginx/nginx.conf"</span>
<span class="k">events</span> <span class="p">{</span>
  <span class="kn">worker_connections</span> <span class="mi">1024</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">http</span> <span class="p">{</span>
  <span class="kn">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">dev.honeymoa.kr</span><span class="p">;</span> <span class="c1"># server_name {도메인}</span>

    <span class="kn">location</span> <span class="n">/.well-known/acme-challenge/</span> <span class="p">{</span>
      <span class="kn">root</span> <span class="n">/var/www/certbot</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
      <span class="kn">return</span> <span class="mi">404</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<details>
<summary><b>nginx.conf 파일 설명</b></summary>
<div>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">events</code> 블록에서는 Nginx 작업자가 동시에 처리할 수 있는 최대 연결 수를 설정합니다. 여기서 <code class="language-plaintext highlighter-rouge">worker_connections 1024;</code>는 각각의 작업자가 최대 1024개의 연결을 동시에 처리할 수 있도록 지정합니다.</p>
      </li>
      <li>
        <p>다음으로, <code class="language-plaintext highlighter-rouge">http</code> 블록 내부에 정의된 <code class="language-plaintext highlighter-rouge">server</code> 블록은 80번 포트를 리스닝하며, 도메인에 대한 요청을 처리합니다.</p>
        <ul>
          <li>첫 번째 <code class="language-plaintext highlighter-rouge">location</code> 블록은 <code class="language-plaintext highlighter-rouge">/.well-known/acme-challenge/</code>경로에 대한 요청을 처리합니다. 여기서는 해당 경로의 요청에 대해 <code class="language-plaintext highlighter-rouge">/var/www/certbot</code> 디렉토리에서 파일을 제공하도록 설정되어 있습니다.</li>
          <li>두 번째 location 블록은 <code class="language-plaintext highlighter-rouge">/</code>로 시작하는 모든 다른 요청에 대해 404 응답을 반환합니다. 인증서 발급 관련 요청 외의 다른 접근을 차단하기 위한 설정입니다.</li>
        </ul>
      </li>
    </ul>
  </div>
</details>
<p><br /></p>

<p>나머지 <code class="language-plaintext highlighter-rouge">/nginx/www/</code>, <code class="language-plaintext highlighter-rouge">/nginx/logs/</code>, <code class="language-plaintext highlighter-rouge">/nginx/ssl/</code> 디렉토리는 Nginx 실행 시 자동으로 생성되기 때문에 수동으로 생성할 필요는 없습니다.</p>

<h2 id="nginx-임시-실행">Nginx 임시 실행</h2>

<p><code class="language-plaintext highlighter-rouge">nginx.conf</code> 파일 작성이 완료되었으므로 이제 Nginx를 실행해보겠습니다.
<br />
<br /></p>

<p><code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> 파일이 있는 디렉토리에서 아래 명령어를 입력하여 Nginx를 실행합니다.<br />
<span style="color:#808080"><em>(만약 <code class="language-plaintext highlighter-rouge">docker-compose</code> 파일의 이름이 다르다면 <code class="language-plaintext highlighter-rouge">-f</code> 옵션을 사용하여 파일 이름을 지정해주셔야 합니다.)</em></span></p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose up <span class="nt">-d</span> nginx
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/nginx-up.png" alt="nginx 실행" /></p>

<p><br />
컨테이너가 정상적으로 실행되었는지 확인합니다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 로그가 없어야 정상적으로 실행된 것입니다.</span>
<span class="nv">$ </span>docker logs nginx

<span class="c"># nginx.conf 파일 문법 검사</span>
<span class="nv">$ </span>docker-compose <span class="nb">exec </span>nginx nginx <span class="nt">-t</span>

<span class="c"># nginx가 실행중인지 확인</span>
<span class="nv">$ </span>docker ps
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/nginx-check.png" alt="nginx 실행 확인" />
<br /></p>

<h2 id="certbot으로-ssl-인증서-발급">Certbot으로 SSL 인증서 발급</h2>

<p>이제 Nginx가 실행되었으니 Certbot을 사용하여 SSL 인증서를 발급받아보겠습니다.<br />
1️⃣ <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> 파일이 있는 디렉토리에서 아래 명령어를 입력하여 Certbot 컨테이너를 실행합니다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose run <span class="nt">--rm</span> certbot
</code></pre></div></div>
<p><br />
2️⃣ 긴급 갱신 및 보안 알림에 사용할 이메일 주소를 입력하라고 나오니 적절한 이메일 주소를 입력해줍니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Saving debug log to /var/log/letsencrypt/letsencrypt.log
Enter email address (used for urgent renewal and security notices)
 (Enter 'c' to cancel):
</code></pre></div></div>
<p><br />
3️⃣ 약관에 동의하라는 메시지가 나오는데, 약관에 동의해야 인증서 발급이 되니 <code class="language-plaintext highlighter-rouge">Y</code>를 입력해줍니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Please read the Terms of Service at:
https://letsencrypt.org/documents/LE-SA-v1.5-February-24-2025.pdf
You must agree in order to register with the ACME server. Do you agree?
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
(Y)es/(N)o: Y
</code></pre></div></div>
<p><br />
4️⃣ 홍보성 메일 수신 여부를 묻는 메시지가 나오는데, 원하시는 대로 선택하시면 됩니다.<br />
저는 메일 수신을 원하지 않아서 <code class="language-plaintext highlighter-rouge">N</code>을 입력했습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Would you be willing, once your first certificate is successfully issued, to
share your email address with the Electronic Frontier Foundation, a founding
partner of the Let's Encrypt project and the non-profit organization that
develops Certbot? We'd like to send you email about our work encrypting the web,
EFF news, campaigns, and ways to support digital freedom.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
(Y)es/(N)o: N
</code></pre></div></div>
<p><br />
📍 <span style="color:#F08080">아래와 같은 에러가 발생한다면 AWS 보안 그룹에서 <code class="language-plaintext highlighter-rouge">80</code>번 포트가 열려있는지 확인해주세요!</span></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Account registered.
Requesting a certificate for dev.honeymoa.kr

Certbot failed to authenticate some domains (authenticator: webroot). The Certificate Authority reported these problems:
  Domain: dev.honeymoa.kr
  Type:   connection
  Detail: 3.39.69.185: Fetching http://dev.honeymoa.kr/.well-known/acme-challenge/SLl0wrWe_5cmAZN6XAX0zq8kboOBEETuiT5WcMvSrtM: Timeout during connect (likely firewall problem)

Hint: The Certificate Authority failed to download the temporary challenge files created by Certbot. Ensure that the listed domains serve their content from the provided --webroot-path/-w and that files created there can be downloaded from the internet.

Some challenges have failed.
Ask for help or search for solutions at https://community.letsencrypt.org. See the logfile /var/log/letsencrypt/letsencrypt.log or re-run Certbot with -v for more details.
</code></pre></div></div>
<p><br />
5️⃣ <span style="color:#32CD32">인증서 발급이 완료되면 아래와 같은 메시지가 출력됩니다.</span></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Requesting a certificate for dev.honeymoa.kr

Successfully received certificate.
Certificate is saved at: /etc/letsencrypt/live/dev.honeymoa.kr/fullchain.pem
Key is saved at:         /etc/letsencrypt/live/dev.honeymoa.kr/privkey.pem
This certificate expires on 2025-06-04.
These files will be updated when the certificate renews.

NEXT STEPS:
- The certificate will need to be renewed before it expires. Certbot can automatically renew the certificate in the background, but you may need to take steps to enable that functionality. See https://certbot.org/renewal-setup for instructions.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
If you like Certbot, please consider supporting our work by:
 * Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate
 * Donating to EFF:                    https://eff.org/donate-le
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
</code></pre></div></div>
<p><br />
인증서 발급에 성공하면 <b><code class="language-plaintext highlighter-rouge">/nginx/ssl/live/{도메인}/</code></b> 디렉토리 안에 인증서와 개인키가 저장됩니다.<br />
인증서와 개인키는 각각 <b><code class="language-plaintext highlighter-rouge">fullchain.pem</code></b>과 <b><code class="language-plaintext highlighter-rouge">privkey.pem</code></b> 파일에 저장됩니다.
<br />
<br />
인증서와 개인키가 정상적으로 발급되었는지 확인하고 싶다면 아래 명령어를 입력하시면 됩니다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 인증서 확인</span>
<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-al</span> /nginx/ssl/live/<span class="o">{</span>도메인<span class="o">}</span>
</code></pre></div></div>
<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/cert-check.png" alt="인증서 확인" />
<br /></p>

<h2 id="docker-composeyaml-파일-업데이트">docker-compose.yaml 파일 업데이트</h2>

<p>인증서 발급이 완료되었으니 아래 명령어를 입력하여 Nginx를 종료합니다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose down
</code></pre></div></div>
<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/nginx-down.png" alt="nginx 종료" />
<br />
<br />
이제 <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> 파일을 완성해봅시다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># file: "docker-compose.yaml"</span>
<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.8'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">honey-moa-dev</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nicodora/honey-moa-dev:latest</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">honey-moa-dev</span>
    <span class="na">env_file</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">.env</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">3000:3000'</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">honey-moa-dev-network</span>

  <span class="na">nginx</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:1.15-alpine</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">80:80'</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">443:443'</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./nginx/nginx.conf:/etc/nginx/nginx.conf</span> <span class="c1"># nginx.conf 파일</span>
      <span class="pi">-</span> <span class="s">./nginx/www/certbot:/var/www/certbot</span> <span class="c1"># certbot이 사용할 디렉토리</span>
      <span class="pi">-</span> <span class="s">./nginx/ssl:/etc/letsencrypt</span> <span class="c1"># ssl 인증서 저장 디렉토리</span>
      <span class="pi">-</span> <span class="s">./nginx/logs:/var/log/nginx</span> <span class="c1"># nginx 로그 저장 디렉토리</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">honey-moa-dev</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">unless-stopped</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">honey-moa-dev-network</span>

  <span class="na">certbot</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">certbot/certbot</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">certbot</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./nginx/www/certbot:/var/www/certbot</span> <span class="c1"># certbot이 사용할 디렉토리</span>
      <span class="pi">-</span> <span class="s">./nginx/ssl:/etc/letsencrypt</span> <span class="c1"># ssl 인증서 저장 디렉토리</span>
    <span class="na">entrypoint</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/bin/sh</span><span class="nv"> </span><span class="s">-c</span><span class="nv"> </span><span class="s">'trap</span><span class="nv"> </span><span class="s">exit</span><span class="nv"> </span><span class="s">TERM;</span><span class="nv"> </span><span class="s">while</span><span class="nv"> </span><span class="s">:;</span><span class="nv"> </span><span class="s">do</span><span class="nv"> </span><span class="s">certbot</span><span class="nv"> </span><span class="s">renew;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">12h</span><span class="nv"> </span><span class="s">&amp;</span><span class="nv"> </span><span class="s">wait</span><span class="nv"> </span><span class="s">$${!};</span><span class="nv"> </span><span class="s">done;'"</span> <span class="c1"># 인증서 자동 갱신</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">unless-stopped</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">honey-moa-dev-network</span>

<span class="na">networks</span><span class="pi">:</span>
  <span class="na">honey-moa-dev-network</span><span class="pi">:</span> <span class="c1"># 네트워크 설정</span>
    <span class="na">driver</span><span class="pi">:</span> <span class="s">bridge</span>
</code></pre></div></div>

<details>
<summary><b>docker-compose.yaml 파일 설명</b></summary>
<div>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> 파일에서 <code class="language-plaintext highlighter-rouge">honey-moa-dev</code>(백엔드 서버), <code class="language-plaintext highlighter-rouge">nginx</code>, <code class="language-plaintext highlighter-rouge">certbot</code> 을 정의합니다.</li>
      <li>nginx 서비스는 80번과 443번 포트를 리스닝하고, 볼륨 마운트를 통해 nginx.conf 파일과 인증서, 로그 디렉토리를 연결합니다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">depends_on:</code> 옵션을 사용하여 Nginx가 백엔드 서버에 의존하도록 설정하여 백엔드 서버가 실행된 후에 시작됩니다.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">certbot</code> 서비스는 <code class="language-plaintext highlighter-rouge">entrypoint</code>를 사용하여 Certbot이 12시간마다 인증서를 갱신하도록 설정했습니다.</li>
      <li><code class="language-plaintext highlighter-rouge">networks:</code> 옵션을 사용하여 <code class="language-plaintext highlighter-rouge">honey-moa-dev-network</code>라는 네트워크를 생성하고, 모든 서비스가 이 네트워크를 사용하도록 설정했습니다.</li>
    </ul>
  </div>
</details>

<h2 id="nginxconf-파일-업데이트">nginx.conf 파일 업데이트</h2>

<p>인증서 발급이 완료되었으므로 요청을 <code class="language-plaintext highlighter-rouge">HTTPS</code>로 받을 수 있도록 <code class="language-plaintext highlighter-rouge">nginx.conf</code> 파일도 업데이트 해줍니다.</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># file: "nginx/nginx.conf"</span>
<span class="k">events</span> <span class="p">{</span>
  <span class="kn">worker_connections</span> <span class="mi">1024</span><span class="p">;</span> <span class="c1"># 워커 프로세스가 처리할 수 있는 최대 연결 수</span>
<span class="p">}</span>

<span class="k">http</span> <span class="p">{</span>
  <span class="kn">upstream</span> <span class="s">backend</span> <span class="p">{</span>
      <span class="kn">server</span> <span class="nf">honey-moa-dev</span><span class="p">:</span><span class="mi">3000</span><span class="p">;</span> <span class="c1"># 백엔드 컨테이너 연결</span>
  <span class="p">}</span>

  <span class="c1"># HTTPS 설정</span>
  <span class="kn">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">dev.honeymoa.kr</span><span class="p">;</span> <span class="c1"># server_name {도메인}</span>

    <span class="kn">ssl_certificate</span> <span class="n">/etc/letsencrypt/live/dev.honeymoa.kr/fullchain.pem</span><span class="p">;</span> <span class="c1"># SSL 인증서 경로</span>
    <span class="kn">ssl_certificate_key</span> <span class="n">/etc/letsencrypt/live/dev.honeymoa.kr/privkey.pem</span><span class="p">;</span> <span class="c1"># SSL 개인키 경로</span>

    <span class="kn">ssl_protocols</span> <span class="s">TLSv1.2</span> <span class="s">TLSv1.3</span><span class="p">;</span>
    <span class="kn">ssl_ciphers</span> <span class="s">HIGH:!aNULL:!MD5</span><span class="p">;</span>

    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
      <span class="kn">proxy_pass</span> <span class="s">http://backend</span><span class="p">;</span>
      <span class="kn">proxy_http_version</span> <span class="mf">1.1</span><span class="p">;</span>
      <span class="kn">proxy_set_header</span> <span class="s">Upgrade</span> <span class="nv">$http_upgrade</span><span class="p">;</span>
      <span class="kn">proxy_set_header</span> <span class="s">Connection</span> <span class="s">'upgrade'</span><span class="p">;</span>
      <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="nv">$host</span><span class="p">;</span>
      <span class="kn">proxy_cache_bypass</span> <span class="nv">$http_upgrade</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1"># HTTP -&gt; HTTPS 리디렉션 설정</span>
  <span class="kn">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">dev.honeymoa.kr</span><span class="p">;</span> <span class="c1"># server_name {도메인}</span>

    <span class="kn">location</span> <span class="n">/.well-known/acme-challenge/</span> <span class="p">{</span>
      <span class="kn">root</span> <span class="n">/var/www/certbot</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kn">return</span> <span class="mi">301</span> <span class="s">https://</span><span class="nv">$host$request_uri</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<details>
<summary><b>nginx.conf 파일 설명</b></summary>
<div>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">upstream backend</code> 블록은 백엔드 서버의 주소를 설정합니다.
        <ul>
          <li>여기서는 <code class="language-plaintext highlighter-rouge">honey-moa-dev:3000</code>으로 설정하여 <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code>에서 정의했던 서비스 이름을 사용합니다.</li>
        </ul>
      </li>
      <li>첫번째 <code class="language-plaintext highlighter-rouge">server</code> 블록은 HTTPS 요청을 처리합니다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">listen 443 ssl;</code>은 443번 포트를 SSL로 리스닝하도록 설정합니다.</li>
          <li><code class="language-plaintext highlighter-rouge">ssl_certificate</code>와 <code class="language-plaintext highlighter-rouge">ssl_certificate_key</code>는 발급받은 SSL 인증서와 개인키의 경로를 설정합니다.</li>
          <li><code class="language-plaintext highlighter-rouge">ssl_protocols</code>와 <code class="language-plaintext highlighter-rouge">ssl_ciphers</code>는 SSL 프로토콜과 암호화 방식을 설정합니다.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">location /</code> 블록은 모든 요청을 백엔드 서버로 프록시 패스합니다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">proxy_pass</code>는 요청을 백엔드 서버로 전달합니다.</li>
          <li><code class="language-plaintext highlighter-rouge">proxy_set_header</code>는 요청 헤더를 설정하여 클라이언트의 정보를 백엔드 서버에 전달합니다.</li>
        </ul>
      </li>
      <li>두번째 <code class="language-plaintext highlighter-rouge">server</code> 블록은 HTTP 요청을 HTTPS로 리디렉션합니다.</li>
    </ul>
  </div>
</details>

<h2 id="docker-compose-실행">docker-compose 실행</h2>
<p>이제 모든 설정이 완료되었으니 아래 명령어를 입력하여 컨테이너를 실행해봅시다!</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose up <span class="nt">-d</span>
</code></pre></div></div>
<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/docker-compose-up.png" alt="docker-compose 실행" />
<br /></p>

<p><code class="language-plaintext highlighter-rouge">Nginx</code> 컨테이너가 정상적으로 실행되었는지 확인:</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># nginx.conf 파일 문법 검사</span>
<span class="nv">$ </span>docker-compose <span class="nb">exec </span>nginx nginx <span class="nt">-t</span>

<span class="c"># HTTPS 요청 확인</span>
<span class="c"># curl -I https://{도메인}</span>
<span class="nv">$ </span>curl <span class="nt">-I</span> https://dev.honeymoa.kr
</code></pre></div></div>
<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/docker-compose-nginx-check.png" alt="docker-compose nginx 실행 확인" />
<br /></p>

<p><code class="language-plaintext highlighter-rouge">Certbot</code> 컨테이너가 정상적으로 실행되었는지 확인:</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># certbot 컨테이너 실행 확인</span>
<span class="nv">$ </span>docker logs certbot
</code></pre></div></div>
<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/docker-compose-certbot-check.png" alt="docker-compose certbot 실행 확인" />
<br /></p>

<p>각 컨테이너들의 실행 확인까지 마치셨다면 SSL 인증서 적용 후, Certbot을 이용한 자동 갱신까지 완성입니다! 🎉</p>

<h2 id="마치며">마치며</h2>

<p>오늘은 AWS EC2 인스턴스에서 Nginx와 Certbot을 사용하여 SSL 인증서를 발급받고 자동갱신까지 설정하는 방법을 알아보았습니다.
처음 SSL 인증서를 발급받는 과정을 접한다면 생소하고, 특히 <code class="language-plaintext highlighter-rouge">nginx.conf</code> 파일과 <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> 파일을 작성하는 부분에서 어려움을 느끼실 수 있는데요. 조급해 하지 말고 차근차근 각 단계에 대해 알아보고 여러번 적용해보면 금방 익숙해질 수 있을겁니다.</p>

<p>그럼 다음 포스트에서 뵙겠습니다! 뾰로롱~
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/frieren1.gif" width="300" height="300" alt="프리렌 움짤1" /></p>]]></content><author><name>NicoDora</name></author><category term="aws" /><summary type="html"><![CDATA[AWS EC2 인스턴스에서 Nginx를 사용하여 Let's encrypt SSL 인증서를 발급받고 Certbot으로 인증서 자동갱신까지 설정하는 방법을 다룹니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/letsencrypt-logo.png" /><media:content medium="image" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/aws/2025-03-07-AWS-EC2에서-Nginx와-Certbot으로-Lets-encrypt-SSL-인증서-발급하기/letsencrypt-logo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Docker 설치하기 for macOS</title><link href="http://localhost:4000/docker/2024/04/03/Docker-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0-for-macOS.html" rel="alternate" type="text/html" title="Docker 설치하기 for macOS" /><published>2024-04-03T15:50:00+09:00</published><updated>2024-04-03T15:50:00+09:00</updated><id>http://localhost:4000/docker/2024/04/03/Docker-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0-for-macOS</id><content type="html" xml:base="http://localhost:4000/docker/2024/04/03/Docker-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0-for-macOS.html"><![CDATA[<ol id="markdown-toc">
  <li><a href="#docker란" id="markdown-toc-docker란">Docker란?</a></li>
  <li><a href="#macos에-docker-설치하기" id="markdown-toc-macos에-docker-설치하기">macOS에 Docker 설치하기</a></li>
  <li><a href="#마치며" id="markdown-toc-마치며">마치며</a></li>
</ol>

<h2 id="docker란">Docker란?</h2>

<p>도커(Docker)는 리눅스 컨테이너를 사용하여 애플리케이션을 더 쉽게 만들고 배포할 수 있도록 해주는 플랫폼입니다. 도커는 컨테이너 이미지를 사용하여 애플리케이션을 빌드하고 배포할 수 있습니다.
<br />
<br />
여기서 <b>컨테이너</b>는 격리된 환경에서 애플리케이션을 실행할 수 있도록 하는 기술입니다.<br />
컨테이너는 필요한 모든 라이브러리, 종속성 및 설정을 포함하는 격리된 패키지로서, 개발자는 개발 환경과 운영 환경 간의 일관성을 유지할 수 있습니다. 또한, 컨테이너는 빠르게 시작되고 쉽게 이동할 수 있어서 애플리케이션을 더 쉽게 배포하고 확장할 수 있습니다.
<br />
<br />
컨테이너 기술의 주요 장점은 다음과 같습니다.</p>
<ol>
  <li>
    <p><b>경량화</b><br />
   가상화된 운영 체제를 사용하는 가상 머신에 비해 더 적은 자원을 사용합니다.</p>
  </li>
  <li>
    <p><b>이식성</b><br />
   컨테이너는 호스트 시스템과 상관없이 동일한 방식으로 동작하므로 이식성이 뛰어납니다.</p>
  </li>
  <li>
    <p><b>일관성</b><br />
   컨테이너는 필요한 라이브러리 및 종속성을 포함하므로 환경이 일관되며, 개발 및 배포 과정이 표준화됩니다.</p>
  </li>
  <li>
    <p><b>확장성</b><br />
   컨테이너는 쉽게 배포되고 확장될 수 있어서 애플리케이션의 요구 사항에 따라 빠르게 조정할 수 있습니다.</p>
  </li>
</ol>

<p><br />
<br />
도커 로고를 보시면 고래가 그려져 있고 그 위에 컨테이너가 올려져 있는 모습을 볼 수 있습니다.<br />
<b>“바다 위에 배가 떠다니면서 그 위에 컨테이너를 올려 놓고 필요할 때마다 컨테이너에 접근하여 사용한다.”</b>라고 생각하시면 좋을 것 같습니다! 😊
<br />
<br />
<br />
<b>이미지</b>는 우리가 흔히 알고 있는 사진이나 그림 파일을 의미하는 것이 아니라, 컨테이너 실행에 필요한 파일과 설정 등을 포함하는 템플릿 입니다.
<br />
<br />
이미지는 값이 변하지 않는 정적인 파일이며, 컨테이너는 이미지를 실행한 상태입니다.<br />
때문에 컨테이너를 삭제하더라도 이미지는 영향을 받지 않고 그대로 남아있습니다.</p>

<p>또, 이미지에는 컨테이너를 실행하기 위해 필요한 모든 파일을 가지고 있기 때문에 복잡하게 이것저것 설정해주지 않아도 간편하게 컨테이너를 실행할 수 있으며, 하나의 이미지로 여러 개의 컨테이너를 실행할 수도 있습니다.</p>

<h2 id="macos에-docker-설치하기">macOS에 Docker 설치하기</h2>

<p>도커에 대한 설명은 간략하게 이 정도로 마치고, 이제 macOS에 도커를 설치해봅시다!</p>

<p><a href="https://www.docker.com/products/docker-desktop/">Docker 다운로드</a> 페이지에 접속하여 본인의 컴퓨터 환경에 맞춰 도커를 다운로드 받습니다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-download-page.png" alt="Docker 다운로드 페이지" />
<br />
<br />
<br />
다운로드가 완료되었다면 다운로드 받은 <code class="language-plaintext highlighter-rouge">Docker.dmg</code>파일을 실행하여 설치를 진행합니다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-install.png" alt="Docker 설치 화면" />
<br />
<br />
<br />
설치가 완료되면 ‘응용프로그램’에서 도커 앱이 추가된 것을 확인할 수 있습니다.</p>

<p>도커 앱을 실행해봅시다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-start.png" alt="Docker 앱 실행" />
<br />
<code class="language-plaintext highlighter-rouge">Accept</code>를 눌러 도커 약관에 동의하고 넘어갑니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-setting.png" alt="Docker 초기 설정" />
<br />
초기 설정은 기본값(추천)으로 설정하고 <code class="language-plaintext highlighter-rouge">Finish</code>를 눌러 다음 단계로 넘어갑니다.
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-signin.png" alt="Docker 로그인" /></p>

<p>도커 허브 계정이 있다면 로그인을 하고, 없다면 스킵하셔도 됩니다.<br />
어짜피 도커는 계속 사용할테니 저는 계정을 새로 만들어서 로그인했습니다.
<br />
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-main.png" alt="Docker 메인화면" />
<br />
이제 도커 설치가 완료되었습니다!
<br />
<br />
<br />
터미널을 열어 아래 명령어를 입력하여 도커가 정상적으로 설치되었는지 확인해봅시다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nt">--version</span>
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-version-check.png" alt="Docker 버전 확인" />
<br />
도커 버전이 출력된다면 정상적으로 설치완료 된 것입니다! 👍</p>

<h2 id="마치며">마치며</h2>

<p>오늘은 도커에 대해 알아보고 macOS에 도커를 설치해봤습니다.<br />
다음 포스트에서는 도커 이미지를 다운받은 후 컨테이너를 실행하고 관리하는 방법에 대해 알아보겠습니다.</p>

<p>그럼 다음 포스트에서 뵙겠습니다! 뾰로롱~
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/frieren1.gif" width="300" height="300" alt="프리렌 움짤1" /></p>]]></content><author><name>NicoDora</name></author><category term="docker" /><summary type="html"><![CDATA[Docker 컨테이너와 이미지에 대해 간단히 살펴보고 macOS환경에서 Docker를 설치해봅시다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-logo.png" /><media:content medium="image" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/docker/2024-04-03-Docker-설치하기-for-macOS/docker-logo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">NestJS 설치 및 시작하기</title><link href="http://localhost:4000/nestjs/2024/03/29/NestJS-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0.html" rel="alternate" type="text/html" title="NestJS 설치 및 시작하기" /><published>2024-03-29T09:57:00+09:00</published><updated>2024-03-29T09:57:00+09:00</updated><id>http://localhost:4000/nestjs/2024/03/29/NestJS-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/nestjs/2024/03/29/NestJS-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0.html"><![CDATA[<ol id="markdown-toc">
  <li><a href="#시작하기-전에" id="markdown-toc-시작하기-전에">시작하기 전에</a></li>
  <li><a href="#nestjs-설치하기" id="markdown-toc-nestjs-설치하기">NestJS 설치하기</a></li>
  <li><a href="#nestjs-기본-프로젝트-구조-살펴보기" id="markdown-toc-nestjs-기본-프로젝트-구조-살펴보기">NestJS 기본 프로젝트 구조 살펴보기</a></li>
  <li><a href="#프로젝트-실행하기" id="markdown-toc-프로젝트-실행하기">프로젝트 실행하기</a></li>
  <li><a href="#마치며" id="markdown-toc-마치며">마치며</a></li>
</ol>

<h2 id="시작하기-전에">시작하기 전에</h2>

<p>NestJS를 설치하기 위해서는 <span style="color:rgb(65, 126, 56)"><b>Node.js</b></span>와 <span style="color:#CC3534"><b>npm</b></span>이 설치되어 있어야 합니다. 만약 설치되어 있지 않다면 <a href="https://nodejs.org/en/download">Node.js 공식 홈페이지</a>에서 Node.js를 설치해주세요.<br />
(Node.js를 설치하면 npm도 함께 설치됩니다.)</p>

<p><br />
Node.js 공식 다운로드 페이지에 들어가면 아래와 같은 화면이 보이게 됩니다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/nodejs-download-page.png" alt="Node.js 공식 홈페이지" /></p>

<p>LTS 버전과 Current 버전이 있는데, LTS 버전은 장기 지원되는 안정적인 버전이고 Current 버전은 최신 기능이 추가된 버전입니다.<br />
Current 버전에서는 예상치 못한 에러가 발생할 수 있으므로 보통은 LTS 버전을 권장합니다.</p>

<p>그 다음으로 본인이 사용중인 컴퓨터 환경을 선택하고 다운로드 해주시면 됩니다!</p>

<blockquote>
  <p>참고로 필자는 ARM 아키텍처를 사용한 애플 실리콘이 탑재된 macOS를 사용하고 있어 위 화면처럼 선택했습니다.</p>
</blockquote>

<p><br />
설치가 완료되었다면 터미널을 열어 아래 명령어를 입력해 Node.js와 npm이 정상적으로 설치되었는지 확인해봅시다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># file: "terminal"</span>
node <span class="nt">-v</span>
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/node-version-check.png" width="500" alt="node 버전 확인" /></p>

<p><br /></p>
<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># file: "terminal"</span>
npm <span class="nt">-v</span>
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/npm-version-check.png" width="500" alt="npm 버전 확인" /></p>

<p><br />
명령어를 입력했을 때 Node.js와 npm의 버전이 출력된다면 정상적으로 설치가 완료된 것입니다.</p>

<p>그럼 이제 NestJS를 설치하러 가봅시다!
<br /></p>

<h2 id="nestjs-설치하기">NestJS 설치하기</h2>

<p><a href="https://docs.nestjs.com">NestJS 공식 문서</a>를 참고하여 해당 포스트를 작성하니 공식 문서를 함께 참고하시면서 따라와주세요. 😊</p>

<p><br />
먼저 NestJS를 설치할 디렉토리를 생성하고 해당 디렉토리로 이동합니다.</p>

<p>저는 간단하게 <code class="language-plaintext highlighter-rouge">nest-project</code>라는 이름으로 디렉토리를 생성해봤습니다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/create-directory.png" width="500" alt="디렉토리 생성" />
<br />
<br />
<br />
그리고 해당 디렉토리 위치에서 아래 명령어를 입력해 <b>NestJS CLI</b><sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>를 설치합니다.
<br />
<br /></p>
<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># file: "NestJS CLI 설치"</span>
npm i <span class="nt">-g</span> @nestjs/cli
</code></pre></div></div>

<blockquote>
  <p>여기서 <code class="language-plaintext highlighter-rouge">-g</code> 옵션은 글로벌 설치를 의미합니다. 글로벌 설치를 하게 되면 어디서든 해당 패키지를 사용할 수 있습니다.</p>
</blockquote>

<p><br />
NestJS CLI를 설치하고 <code class="language-plaintext highlighter-rouge">nest</code>명령어를 입력하면 아래와 같이 사용할 수 있는 명령어들이 출력됩니다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/nest-command.png" alt="nest 명령어 확인" />
<br />
<br />
<br />
이제 <code class="language-plaintext highlighter-rouge">nest new {project-name}</code> 명령어를 통해 새로운 NestJS 프로젝트를 생성해봅시다.</p>

<p>필자는 <code class="language-plaintext highlighter-rouge">blog-nest</code>라는 이름으로 프로젝트를 생성해보겠습니다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/nest-new-project.png" width="700" alt="nest new 명령어로 프로젝트 생성" /></p>

<p>패키지 매니저를 선택하라는 메시지가 나오는데 필자는 <code class="language-plaintext highlighter-rouge">npm</code>을 선택했습니다.<br />
(화살표 키를 이용해 선택하고 엔터키를 누르면 됩니다.)
<br />
<br />
<br /></p>

<p class="figcaption"><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/new-project-create-loading.png" width="700" alt="프로젝트 생성중" /><br />
프로젝트 생성중인 모습</p>

<p><br />
프로젝트 생성이 완료되면 아래와 같이 성공적으로 프로젝트가 생성되었다고 메세지가 출력되네요!</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/install-success.png" width="700" alt="프로젝트 생성 성공" /></p>

<p><br />
이제 <code class="language-plaintext highlighter-rouge">code .</code> 명령어를 통해 해당 프로젝트 디렉토리를 VSCode에서 열어 구조를 살펴보러 가봅시다.</p>

<h2 id="nestjs-기본-프로젝트-구조-살펴보기">NestJS 기본 프로젝트 구조 살펴보기</h2>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/open-vscode.png" width="300" alt="VSCode에서 프로젝트 열기" /></p>

<p>VSCode에서 자세히 살펴보면 위 사진처럼 <code class="language-plaintext highlighter-rouge">blog-nest</code>라는 프로젝트 디렉토리가 생성되었고, 그 안에 노드 모듈과 src/ 디렉토리 안에 NestJS의 핵심 파일이 생성된 것을 확인할 수 있습니다.</p>

<p><br /></p>
<pre><code class="language-none">nest-project
└─ blog-nest
   ├─ src
   │  ├─ app.controller.spec.ts
   │  ├─ app.controller.ts
   │  ├─ app.module.ts
   │  ├─ app.service.ts
   │  └─ main.ts
   ├─ test
   │  ├─ app.e2e-spec.ts
   │  └─ jest-e2e.json
   ├─ .eslintrc.js
   ├─ .prettierrc
   ├─ README.md
   ├─ nest-cli.json
   ├─ package-lock.json
   ├─ package.json
   ├─ tsconfig.build.json
   └─ tsconfig.json
</code></pre>
<p class="figcaption">project tree</p>

<p><br />
핵심 파일들의 간략한 개요:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">파일명</th>
      <th style="text-align: left">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">app.controller.ts</code></td>
      <td style="text-align: left">컨트롤러 파일로, 클라이언트의 요청을 받아 처리하는 역할을 합니다.</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">app.controller.spec.ts</code></td>
      <td style="text-align: left">컨트롤러의 테스트 코드를 작성하는 파일입니다.</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">app.module.ts</code></td>
      <td style="text-align: left">애플리케이션의 루트 모듈입니다.</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">app.service.ts</code></td>
      <td style="text-align: left">서비스 파일로, 비즈니스 로직을 처리하는 역할을 합니다.</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">main.ts</code></td>
      <td style="text-align: left">Nest 애플리케이션 인스턴스를 생성하기 위해 핵심 함수 <code class="language-plaintext highlighter-rouge">NestFactory</code>를 사용하는 애플리케이션의 엔트리 파일입니다.</td>
    </tr>
  </tbody>
</table>

<p><br />
NestJS로 프로젝트를 진행하기 위해선 반드시 Controller, Service, Module을 이해하고 있어야 합니다…!<br />
지금 모두 설명하기에는 무리가 있으니 이에 대한 자세한 내용은 다음 포스트에서 다루도록 하겠습니다.</p>

<h2 id="프로젝트-실행하기">프로젝트 실행하기</h2>

<p>이제 프로젝트를 실행해 볼텐데, <code class="language-plaintext highlighter-rouge">package.json</code> 파일을 열어봅시다.</p>

<p><br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/package-json-scripts.png" alt="package.json 파일" /></p>

<p><code class="language-plaintext highlighter-rouge">scripts</code> 부분을 보면 다양한 명령어들이 적혀있는데, <code class="language-plaintext highlighter-rouge">npm run</code>과 함께 해당 명령어를 입력하면 옵션에 따라 다르게 서버를 실행할 수 있습니다.</p>

<p>일단은 <code class="language-plaintext highlighter-rouge">npm run start:dev</code> 명령어를 입력해 개발 서버를 실행해봅시다.</p>

<p>dev 옵션으로 서버를 실행하면 파일이 변경될 때마다 자동으로 서버가 재시작됩니다.<br />
개발중에는 위 명령어를 사용하여 서버를 실행하는 것을 추천합니다.
<br />
<br />
<br />
혹시나 아래와 같은 에러가 발생한다면 <code class="language-plaintext highlighter-rouge">cd {프로젝트 이름}</code> 명령어를 통해 프로젝트 디렉토리 안으로 이동 한 후 명령어를 입력해주세요!</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/missing-script-error.png" alt="missing script error" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm ERR! Missing script: "start:dev"
npm ERR! 
npm ERR! To see a list of scripts, run:
npm ERR!   npm run

npm ERR! A complete log of this run can be found in: /Users/nicodora/.npm/_logs/2024-03-28T12_55_04_707Z-debug-0.log
</code></pre></div></div>
<p><br />
<br />
서버를 성공적으로 실행했다면 아래와 같이 서버가 정상적으로 실행되었다는 메세지가 출력됩니다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/server-start-success.png" alt="서버 실행 성공" />
<br />
<br />
<br />
브라우저에서 <a href="http://localhost:3000"><code class="language-plaintext highlighter-rouge">http://localhost:3000</code></a> 혹은 <code class="language-plaintext highlighter-rouge">http://127.0.0.1:3000</code>으로 접속하면 아래와 같이 <code class="language-plaintext highlighter-rouge">Hello World!</code>라는 메세지가 출력되는 것을 확인할 수 있습니다.</p>

<p><img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/localhost.png" width="700" alt="localhost 접속" /></p>

<h2 id="마치며">마치며</h2>

<p>오늘은 NestJS를 설치하고 기본 구조를 살펴보며 <code class="language-plaintext highlighter-rouge">Hello World!</code>서버를 실행시켜봤습니다.
<br />
<br />
NestJS를 설치하고 단 한 줄의 코드를 작성하지 않았음에도 간단하게 서버를 구동할 수 있었습니다. 👍<br />
(역시 킹갓 NestJS 😎)</p>

<p>다음 포스트에서는 NestJS의 핵심인 Controller, Service, Module에 대해 자세히 알아보고 직접 코드를 작성해보는 시간을 갖도록 하겠습니다.</p>

<p>그럼 다음 포스트에서 뵙겠습니다! 뾰로롱~
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/frieren1.gif" width="300" height="300" alt="프리렌 움짤1" /></p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>CLI(Command Line Interface)는 명령어를 통해 프로그램을 제어하는 인터페이스를 의미합니다. NestJS CLI는 NestJS 프로젝트를 생성하고 관리하는 명령어를 제공합니다. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>NicoDora</name></author><category term="nestjs" /><summary type="html"><![CDATA[NestJS를 설치하고 기본 구조를 살펴보며 NestJS를 사용해서 프로젝트를 시작해봅시다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/nestjs-logo.png" /><media:content medium="image" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-29-NestJS-설치-및-시작하기/nestjs-logo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">NestJS를 선택한 이유 (NestJS란?)</title><link href="http://localhost:4000/nestjs/2024/03/22/NestJS%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%9D%B4%EC%9C%A0.html" rel="alternate" type="text/html" title="NestJS를 선택한 이유 (NestJS란?)" /><published>2024-03-22T21:20:00+09:00</published><updated>2024-03-22T21:20:00+09:00</updated><id>http://localhost:4000/nestjs/2024/03/22/NestJS%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%9D%B4%EC%9C%A0</id><content type="html" xml:base="http://localhost:4000/nestjs/2024/03/22/NestJS%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%9D%B4%EC%9C%A0.html"><![CDATA[<ol id="markdown-toc">
  <li><a href="#nestjs란" id="markdown-toc-nestjs란">NestJS란?</a></li>
  <li><a href="#nestjs를-선택하기-전에" id="markdown-toc-nestjs를-선택하기-전에">NestJS를 선택하기 전에</a></li>
  <li><a href="#nestjs를-선택한-이유" id="markdown-toc-nestjs를-선택한-이유">NestJS를 선택한 이유</a></li>
  <li><a href="#지금부터는" id="markdown-toc-지금부터는">지금부터는</a></li>
</ol>

<h2 id="nestjs란">NestJS란?</h2>

<p>NestJS는 효율적이고 확장 가능한 Node.js 서버 측 애플리케이션을 구축하기 위한 프레임워크입니다. 진보적인 자바스크립트를 사용하고, TypeScript로 구축되어 완전히 지원하며(순수 자바스크립트로도 가능), OOP(Object Oriented Programming)<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, FP(Functional Programming)<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>, FRP(Functional Reactive Programming)<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>의 요소를 결합합니다.</p>

<p>내부적으로 Nest는 Express(기본값)와 같은 강력한 HTTP 서버 프레임워크를 사용하며, 선택적으로 Fastify도 사용하도록 구성할 수 있습니다!</p>

<p>Nest는 이러한 일반적인 Node.js 프레임워크(Express/Fastify)보다 높은 수준의 추상화를 제공할 뿐만 아니라 개발자에게 직접 API를 노출합니다. 따라서 개발자는 기본 플랫폼에서 사용할 수 있는 수많은 타사 모듈을 자유롭게 사용할 수 있습니다.</p>

<p><i><a href="https://docs.nestjs.com/">공식 문서</a> 참고.</i>
<br /></p>

<h2 id="nestjs를-선택하기-전에">NestJS를 선택하기 전에</h2>

<p>Modern-Agile 6기 백엔드로 활동하며 메인 프로젝트(<span style="color:#FF772B">멘보샤 프로젝트</span>)를 진행하였습니다.</p>

<p>프로젝트를 진행할 때 어떤 프레임워크를 사용할지에 대해 백엔드 팀원분들과 논의를 하였고, 결론적으로는 NestJS를 사용하기로 결정하였습니다. 그렇다면 저희가 왜 NestJS를 사용하게 되었을까요? 지금부터 그 이유를 다시 생각해보며 끄적여보겠습니다.
<br />
<br />
먼저, 모던애자일은 웹개발을 하고 싶은 열정은 가지고 있지만 어떻게 시작해야할지 막막한 사람들을 위해 애자일 방법론을 기반으로 웹 개발을 함께 배우는 방법을 제시하는 전문 동아리 입니다.<br />
때문에 다른 사람들도 아직 백엔드를 할지 프론트엔드를 할지조차 정하지 못한 상태로 들어오는 경우가 많아 백,프론트 두 곳에서 모두 사용할 수 있는 javascript를 사용해서 코딩테스트를 풀며 언어에 익숙해지는 시간을 갖게 되는데, 그러다보니 자연스럽게 미니 프로젝트에서는 javascript를 사용하는 node.js기반의 Express 프레임워크를 채택하게 되었습니다.
<br />
<br />
이제, 메인 프로젝트를 진행해야하는 시간이 다가왔습니다.<br />
그동안에 Express를 사용해 왔었는데 메인 프로젝트를 진행할때는 다른 프레임워크를 사용할지 아니면 Express를 계속 사용할지에 대해 논의를 하였습니다.<br />
사실 ‘새로운 프레임워크를 배우면서 동시에 프로젝트에 적용하는게 힘들지 않을까?’ 라는 두려움에 Express를 계속 사용하고 싶었지만… Express를 사용하면서 느꼈던 불편함도 해결해보고 싶었고 새로운 기술을 배우며 프로그래밍에 대한 시야를 넓히고 싶었기에 새로운 프레임워크를 사용하기로 결정하였습니다.
<br />
<br />
<br /></p>
<blockquote>
  <p><b>Express를 사용하면서 느낀 가장 큰 단점은 “하나부터 열까지 개발자가 정하고 구현해야 한다” 였습니다.</b></p>
</blockquote>

<p><br />
Express는 제약이 없어 구조가 자유롭다는 장점이 있지만, 이는 개발자가 코드를 어떻게 구조화할지에 대한 명확한 가이드라인이 없다는 것을 의미합니다. 미니 프로젝트임에도 불구하고 디자인 패턴부터 에러 핸들링, 라이프사이클 관리까지 모든 것을 개발자가 스스로 정하고 구현해야 했기에 매우 귀찮고 힘들었습니다.
<br />
개발자가 개입할 수 있는 부분이 많다는 건 결국 개발자가 해야할 일이 많아지고 오류가 발생할 확률도 높아지는 것이니까요.</p>

<p>결국 위와 같은 이유로 Express는 프로젝트 규모가 커지면 사용하기 어렵다는 결론에 도달하게 되었습니다.
<br /></p>

<h2 id="nestjs를-선택한-이유">NestJS를 선택한 이유</h2>

<p>이제 Express의 단점을 보완시켜줄 프레임워크로 NestJS를 선택한 이유에 대해 설명드리겠습니다.</p>

<p><b>1. 구조화된 아키텍처</b><br />
NestJS는 Provider, Module, Controller, Service, Middleware, Pipe, Guard, Decorator, Filter, Exception Filter 등의 요소들을 제공하며, 이러한 요소들을 조합하여 구조화된 아키텍처를 구축할 수 있습니다. 이러한 구조화된 아키텍처는 프로젝트 규모가 커질수록 코드의 가독성과 유지보수성을 높여줍니다.<br />
기능 구현하기도 바쁜 저희 팀에게는 매우 큰 장점이 될 것이라고 생각되었습니다.
<br />
<br />
<b>2. TypeScript 사용</b><br />
NestJS는 TypeScript로 쓸 것을 가정하고 만들어진 프레임워크입니다. TypeScript를 사용하면 정적 타입 검사를 통해 런타임 에러를 줄일 수 있고, 코드의 가독성을 높일 수 있습니다.
<br />
<br />
<b>3. 잘 정리되어 있는 공식 문서</b><br />
처음에 데코레이터, 파이프, 프로바이더 등의 용어가 생소했지만, 공식 문서가 잘 정리되어 있다는 점에서 NestJS를 안심하고 선택할 수 있었던 것 같습니다.
<br />
<br />
결론적으로 NestJS를 사용하여 메인 프로젝트를 진행하게 된 것이 좋은 선택이었다고 생각합니다.</p>

<h2 id="지금부터는">지금부터는</h2>
<p><del>그 뒤는 안돼 임마!</del><br />
NestJS를 사용하여 프로젝트에서 제가 구현했던 기능들부터 다른 팀원분들이 구현했던 기능들도 직접 한번 구현해보면서<br />
차근차근 포스팅 해보겠습니다! 😊</p>

<p>그럼 다음 포스트에서 뵙겠습니다 뾰로롱~
<br />
<br />
<img src="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/frieren1.gif" width="300" height="300" alt="프리렌 움짤1" /></p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>객체 지향 프로그래밍(Object Oriented Programming, OOP)은 컴퓨터 프로그래밍의 패러다임 중 하나로, 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 “객체”들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고 데이터를 처리할 수 있다. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>함수형 프로그래밍(Functional Programming, FP)은 계산을 수학적 함수의 평가로 간주하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임이다. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>함수형 반응형 프로그래밍(Functional Reactive Programming, FRP)은 함수형 프로그래밍과 반응형 프로그래밍을 결합한 프로그래밍 패러다임이다. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>NicoDora</name></author><category term="nestjs" /><summary type="html"><![CDATA[NestJS가 무엇인지 알아보고 Modern-Agile 6기 메인 프로젝트에서 왜 NestJS를 채택했는지 알아봅시다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-22-NestJS를-선택한-이유/nestjs-logo.png" /><media:content medium="image" url="https://cdn.jsdelivr.net/gh/NicoDora/nicodora.github.io/assets/img/nestjs/2024-03-22-NestJS를-선택한-이유/nestjs-logo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>